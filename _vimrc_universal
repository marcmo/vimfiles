" start vim without using this .vimrc file:  vim -u NORC
" start vim without loading any .vimrc or plugins: vim -u NONE
"
filetype off                    " force reloading *after* pathogen loaded
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

" let Vundle manage Vundle
" required! 
Bundle 'gmarik/vundle'
" original repos on github
Bundle 'tpope/vim-fugitive'
Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-repeat'
Bundle 'godlygeek/tabular'
Bundle 'tomtom/tcomment_vim'
Bundle 'scrooloose/nerdtree'
Bundle 'digitaltoad/vim-jade'
Bundle 'thinca/vim-quickrun'
Bundle 'sjl/gundo.vim'
Bundle 'msanders/snipmate.vim'
Bundle 'kien/ctrlp.vim'
Bundle 'marcmo/haskellmode-vim'
Bundle 'Rip-Rip/clang_complete'
Bundle 'ervandew/supertab'
Bundle 'Raimondi/delimitMate'
Bundle 'derekwyatt/vim-fswitch'
Bundle 'altercation/vim-colors-solarized'
" vim-scripts repos
Bundle 'L9'
Bundle 'bufkill.vim'
Bundle 'BufOnly.vim'
Bundle 'taglist.vim'
Bundle 'DrawIt'
Bundle 'matchit.zip'
Bundle 'mru.vim'
" non github repos

filetype plugin indent on     " required!

syntax on
set background=dark
colorscheme solarized
if has('gui_running')
  set guitablabel=%t            " only display the filename not the path
  set guioptions-=T             " remove toolbar
  set guioptions-=m             " remove menu bar
  set cursorline
else
  set t_Co=16
endif

set wildignore+=*.o,*.obj,*.o.d,.git,*.a,*.d
set showmode                    " always show what mode we're currently editing in
set wrap                        " don't wrap lines
set tabstop=2                   " a tab is 2 spaces by default
set softtabstop=2               " when hitting <BS>, pretend like a tab is removed, even if spaces
set expandtab                   " expand tabs default
set shiftwidth=2                " number of spaces to use for autoindenting
set shiftround                  " use multiple of shiftwidth when indenting with '<' and '>'
set backspace=indent,eol,start  " allow backspacing over everything in insert mode
set autoindent                  " always set autoindenting on
set copyindent                  " copy the previous indentation on autoindenting
" set number                      " always show line numbers
set ignorecase                  " ignore case when searching
set smartcase                   " ignore case if all lowercase, otherwise case-sensitive
set smarttab                    " insert tabs on the start of a line according to shiftwidth
set scrolloff=1                 " keep 1 line off the edges of the screen when scrolling
set virtualedit=block           " allow virtual editing in Visual block mode.
set hlsearch                    " highlight search terms
set incsearch                   " show search matches as you type
set completeopt=longest,menuone,preview
set wildmode=longest:full       " bash like filename completion
set wildmenu                    " show possible completions for filenames
set nocompatible                " make Vim behave in a more useful way, less vi compatible
set hidden
set noswapfile                  " disable swapfiles
set dictionary+=/usr/share/dict/words
set history=1000               " keep 1000 lines of command line history
set ruler                      " show the cursor position all the time
set showcmd                    " show (partial) command in the last line of the screen
set smartindent                " do smart autoindenting when starting a new line
set vb                         " visual beep
set autoread                   " reload file if permissions change due to BufWritePost below
set autowrite                  " write file to disk on :make, :!, :first, :next
set gcr=n:blinkon0             " turn of blinking cursor in normal mode
" use normal regexes in search
nnoremap / /\v
vnoremap / /\v
" ctags - Open the definition in a vertical split
map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
" jump back to last file
inoremap <C-Tab> <Esc>:e#<CR>
noremap <C-Tab> :e#<CR>
imap <C-S-Tab> <Esc> :bp<CR>
map <C-S-Tab> :bp<CR>

noremap ;' :%s:::cg<Left><Left><Left><Left>
" leave the cursor at the point where it was before editing started
nmap . .`[

" plugin specific config ------------------------------
let g:clang_auto_select=1
let g:clang_complete_auto=0
let g:clang_complete_copen=1
let g:clang_snippets=1
let g:clang_snippets_engine = "snipmate"
let g:clang_exec="clang"
let g:clang_user_options=""
let g:clang_auto_user_options="path, .clang_complete"
let g:clang_use_library=1
let g:clang_library_path="/usr/local/lib"

let g:clang_sort_algo="priority"
let g:clang_complete_macros=1
let g:clang_complete_patterns=0
nnoremap <Leader>q :call g:ClangUpdateQuickFix()<CR>
" plugin:quickrun
let g:quickrun_config = {}
let g:quickrun_config.haskell = {'eval' : 1 }
let g:quickrun_config.c = {'type' : 
\     executable('clang')          ? 'c/clang' :
\     executable('gcc')            ? 'c/gcc' : ''}
" plugin:fugitiv
function! CloseFugativeDiffAfterUsage()
  diffoff!
  close
  wincmd k
endfunction
autocmd BufReadPost fugitive://* set bufhidden=delete
set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
" plugin:supertag
let g:SuperTabMappingForward = '<c-space>'
let g:SuperTabMappingBackward = '<s-c-space>'
let g:SuperTabLongestHighlight = 1
let g:SuperTabDefaultCompletionType = 'context'
" plugin:fswitch
let g:fsnonewfiles=1
let g:fswitchnonewfiles=1
" Create the destination path by substituting any 'include' string from the pathname with 'src'
let b:fswitchlocs = 'reg:/include/src/'
if has("autocmd")
  augroup mycppfiles
    au!
    au BufEnter *.h let b:fswitchdst  = 'cpp,cc,C'
    au BufEnter *.h let b:fswitchlocs = 'reg:/include/src/,reg:/include.*/src/,..'
    au BufEnter *.c  let b:fswitchdst  = 'h'
    au BufEnter *.c  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include'
    au BufEnter *.cpp  let b:fswitchdst  = 'h'
    au BufEnter *.cpp  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include,include'
  augroup END
endif
" plugin:mru
let MRU_Max_Entries = 200 
let MRU_Window_Height = 25 
" plugin:ctrlp
let g:ctrlp_max_height = 25
let g:ctrlp_custom_ignore = '^\.git$\|\.hg$\|\.svn$'
let g:ctrlp_by_filename = 1
let g:ctrlp_max_files = 30000
let g:ctrlp_match_window_bottom = 0
let g:ctrlp_match_window_reversed = 0
" plugin:haskell syntax config
let hs_highlight_delimiters = 1 " Highlight delimiter characters
let hs_highlight_boolean = 1 " Treat True and False as keywords.
let hs_highlight_types = 1 " Treat names of primitive types as keywords.
let hs_highlight_more_types = 1 " Treat names of other common types as keywords.

" for using ctags
set tags=tags;$HOME

" mapping of F-*
map <F1> :CtrlPBuffer<CR>
imap <F1> <esc>:CtrlPBuffer<CR>
map <F2> :copen<CR>
map <S-F2> :cclose<CR>
" lookup symbol in tags file
imap <F3> <Esc><c-]><CR>
map <F3> <c-]><CR>
nmap <F4> :call ToggleSpell()<CR>
imap <F4> <Esc>:call ToggleSpell()<CR>a
" Prepare a :substitute command using the current word or the selected text:
vnoremap <F6> y:%s/\<<C-r>"\>//gc<Left><Left><Left>
nmap <F6> y:%s/\<<C-r>=expand("<cword>")<CR>\>//gc<Left><Left><Left>
map <F7> :call OpenInTerminal()<CR><CR>
" search for the keyword under the cursor in the current directory using the 'grep' command
nnoremap <F8> :grep <C-R><C-W> *<CR>
map <S-F8> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --exclude=*.html .<CR>
nnoremap <silent> <F9> :TlistToggle<CR>
map <S-F9> :set wrap!<CR> " toggle wrap lines
nnoremap <F10> :GundoToggle<CR>
nnoremap <S-F11> g- 
nnoremap <S-F12> g+ 
" highlight current word with <F12> and on mouse click
nnoremap <LeftRelease> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
inoremap <LeftRelease> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
noremap <F12> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
inoremap <F12> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
nnoremap <silent> <F11> :YRShow<CR>

" Will allow you to use :w!! to write to a file using sudo if you forgot to sudo vim file (will prompt password)
cmap w!! %!sudo tee > /dev/null %
vmap // y/<C-R>"<CR> " search for visually highlighted text
" use ghc functionality for haskell files
au BufEnter *.hs compiler ghc
function! GhciMake()
  cd %:h
  set makeprg=ghci\ %
  make
endfunction
function! GetVisualSelection()
  try
    let a_save = @a
    normal! gv"ay
    echo @a
    return @a
  finally
    let @a = a_save
  endtry
endfunction

function! EvaluateInGhc() range
  let current = GetVisualSelection()
  let result = system('ghc -e '.shellescape(current))
  call setline(".", result)
endfunction
vmap <leader>e :call EvaluateInGhc()<CR>$x<esc>0
" quick way to escape from insert mode
inoremap jj <ESC>

" Spell check
function! ToggleSpell()
  if !exists("b:spell")
    setlocal spell spelllang=en_us
    let b:spell = 1
  else
    setlocal nospell
    unlet b:spell
  endif
endfunction
function! SwitchWindowKeepCurrentDir()
  let current = getcwd()
  wincmd W
  cd `=current`
endfunction

function! RakeCommand(command)
  cexpr system("rake " . a:command)
  cw " show quickfix window already
endfunction
command! -nargs=+ -complete=file Rake call RakeCommand(<q-args>)
" use ack to search in files
function! AckGrep(command)
  " execute 'NERDTreeToggle' 
  cexpr system("ack-grep " . a:command)
  " execute 'NERDTreeToggle' 
  " wincmd l
  cw " show quickfix window already
endfunction
command! -nargs=+ -complete=file Ack call AckGrep(<q-args>)

" prompt for opening files in the same dir as the current buffer's file.
if has("unix")
  let g:os_specific_delimiter="/"
else
  let g:os_specific_delimiter="\\"
endif
map ,e :e <C-R>=expand("%:p:h") . g:os_specific_delimiter <CR>
"Vertical split then hop to new buffer
nnoremap ,v :vsp<CR>^W^W<CR>
nnoremap ,h :split<CR>^W^W<CR>
nnoremap ,rc :e ~/.vim/_vimrc_universal <CR>
nnoremap <silent> ,rr :QuickRun -mode n<CR>
vnoremap <silent> ,rr :QuickRun -mode v<CR>
nnoremap <silent>,, :FSHere<cr>
vnoremap <silent>,, :FSHere<cr>
nnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
vnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
"Make current window the only one
nnoremap ,O :onlyR>:tabo<CR>
nnoremap ,o :only<CR>
nnoremap <silent>,m :cd %:p:h<CR> :execute 'make'<CR>
nnoremap ,u :MRU<CR>
nnoremap ,w :BD<CR>
" set current dir to that of current file
map ,cd :call ToCurrentDir()<CR>
noremap ,d :execute 'NERDTreeToggle ' . getcwd()<CR><C-W><C-W><CR>
noremap ,f :execute 'NERDTreeFind'<CR> 
noremap ,k :call CloseFugativeDiffAfterUsage()<CR> 
function! ToCurrentDir()
  cd %:p:h
  :pwd
endfunction 

map <leader>a :Ack<space>-G ".*\.(c\|cpp\|h\|hs\|lua\|rb)"<space>
nmap<leader>x <Plug>ToggleAutoCloseMappings
map <leader>r :Rake<space>
nmap<leader>l :set list!<CR>
map <leader>b :!open -a Google\ Chrome %<CR><CR>
map <leader>u :cd ..<CR>:pwd<CR>
map <leader>t :CtrlP .<CR>

" create html from text
function! Text2html()
  runtime! syntax/2html.vim :convert txt to html
endfunction 
command! Txt2html :call Text2html()

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
      \ | wincmd p | diffthis
endif
if has("autocmd")
  augroup mkd
    autocmd BufRead *.mkd,*.md,*.markdown  set ai formatoptions=tcroqn2 comments=n:&gt;
  augroup END
  augroup hs
    autocmd bufenter *.hs,*.lhs map <F5> :call OpenInGhci()<CR><CR>
    autocmd bufenter *.hs,*.lhs setlocal ts=2 sts=2 sw=2 expandtab
  augroup END
  augroup lua
  setlocal mp=lua\ % ts=2 sts=2 sw=2 noexpandtab
  " autocmd BufRead,BufNewFile *.lua set iskeyword+=.,:
    autocmd bufenter *.lua map <F5> :call OpenWithLua()<CR><CR>
  augroup END
  autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
  autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType c,cpp,java setlocal ts=4 sts=4 sw=4 expandtab
  augroup html
      setlocal ts=2 sts=2 sw=2 expandtab
      set makeprg=jslint\ %
      setlocal efm=%f:%l:%c:%m
  augroup END
  augroup js
      setlocal ts=2 sts=2 sw=2 expandtab
      set makeprg=jslint\ %
      setlocal efm=%f:%l:%c:%m
  augroup END

  autocmd BufRead,BufNewFile *.rb set iskeyword+=?,!
  autocmd BufRead,BufNewFile *.rss setfiletype xml
endif

