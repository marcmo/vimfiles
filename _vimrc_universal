" To start vim without using this .vimrc file, use:
"     vim -u NORC
"
" To start vim without loading any .vimrc or plugins, use:
"     vim -u NONE
"
" Use pathogen to easily modify the runtime path to include all plugins under
" the ~/.vim/bundle directory
"
filetype off                    " force reloading *after* pathogen loaded
call pathogen#helptags()
call pathogen#runtime_append_all_bundles()
filetype plugin indent on       " enable detection, plugins and indenting in one step
if has('gui_running')
  set guitablabel=%t            " only display the filename not the path
  set guioptions-=T             " remove toolbar
  set guioptions-=m             " remove menu bar
  set cursorline
  " colorscheme delek_local     " personal copy of delek color scheme
  colorscheme camo
else
  colorscheme desert
endif
syntax on


set showmode                    " always show what mode we're currently editing in
set wrap                      " don't wrap lines
set tabstop=2                   " a tab is 2 spaces by default
set softtabstop=2               " when hitting <BS>, pretend like a tab is removed, even if spaces
set expandtab                   " expand tabs default
set shiftwidth=2                " number of spaces to use for autoindenting
set shiftround                  " use multiple of shiftwidth when indenting with '<' and '>'
set backspace=indent,eol,start  " allow backspacing over everything in insert mode
set autoindent                  " always set autoindenting on
set copyindent                  " copy the previous indentation on autoindenting
set number                      " always show line numbers
set ignorecase                  " ignore case when searching
set smartcase                   " ignore case if all lowercase, otherwise case-sensitive
set smarttab                    " insert tabs on the start of a line according to shiftwidth
set scrolloff=1                 " keep 1 line off the edges of the screen when scrolling
set virtualedit=block           " allow virtual editing in Visual block mode.
set hlsearch                    " highlight search terms
set incsearch                   " show search matches as you type
set completeopt=longest,menuone,preview
set wildmode=longest:full       " bash like filename completion
set wildmenu                    " show possible completions for filenames
set nocompatible                " make Vim behave in a more useful way, less vi compatible
set hidden
set noswapfile                  " disable swapfiles
set dictionary+=/usr/share/dict/words
set history=1000               " keep 1000 lines of command line history
set ruler                      " show the cursor position all the time
set showcmd                    " show (partial) command in the last line of the screen
set smartindent                " do smart autoindenting when starting a new line
set vb                         " visual beep
set autoread                   " reload file if permissions change due to BufWritePost below
set autowrite                  " write file to disk on :make, :!, :first, :next
" use normal regexes in search
nnoremap / /\v
vnoremap / /\v
" ctags - Open the definition in a vertical split
map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
" jump back to last file
inoremap <C-Tab> <Esc>:e#<CR>
noremap <C-Tab> :e#<CR>
imap <C-S-Tab> <Esc> :bp<CR>
map <C-S-Tab> :bp<CR>

noremap ;; :%s:::g<Left><Left><Left>
noremap ;' :%s:::cg<Left><Left><Left><Left>
" leave the cursor at the point where it was before editing started
nmap . .`[

" plugin specific config ------------------------------
" plugin: CommandT
let g:CommandTMaxFiles=50000
" plugin:fugitiv
autocmd BufReadPost fugitive://* set bufhidden=delete
set statusline=%<%f\ %h%m%r%{fugitive#statusline()}%=%-14.(%l,%c%V%)\ %P
" plugin:supertag
let g:SuperTabMappingForward = '<c-space>'
let g:SuperTabMappingBackward = '<s-c-space>'
let g:SuperTabLongestHighlight = 1
let g:SuperTabDefaultCompletionType = 'context'
" plugin:getlatest
let g:GetLatestVimScripts_allowautoinstall=1
" plugin:fswitch
let g:fsnonewfiles=1
let g:fswitchnonewfiles=1
" Create the destination path by substituting any 'include' string from the pathname with 'src'
let b:fswitchlocs = 'reg:/include/src/'
if has("autocmd")
  augroup mycppfiles
    au!
    au BufEnter *.h let b:fswitchdst  = 'cpp,cc,C'
    au BufEnter *.h let b:fswitchlocs = 'reg:/include/src/,reg:/include.*/src/'
    au BufEnter *.c  let b:fswitchdst  = 'h'
    au BufEnter *.c  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include'
    au BufEnter *.cpp  let b:fswitchdst  = 'h'
    au BufEnter *.cpp  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include'
  augroup END
endif
" plugin:ctags
let g:ctags_statusline=1
set tags=tags;$HOME
" plugin:mru
let MRU_Max_Entries = 200 
let MRU_Window_Height = 25 
" plugin:haskell syntax config
let hs_highlight_delimiters = 1 " Highlight delimiter characters
let hs_highlight_boolean = 1 " Treat True and False as keywords.
let hs_highlight_types = 1 " Treat names of primitive types as keywords.
let hs_highlight_more_types = 1 " Treat names of other common types as keywords.

"mapping of F-*
imap <S-F1> <esc>:BufExplorer<CR>
map <S-F1> :BufExplorer<CR>
map <F1> :FufBuffer<CR>
imap <F1> <esc>:FufBuffer<CR>
map <F2> :FufFile **/<CR>
map <S-F2> :FufDir<CR>
" lookup symple in tags file
imap <F3> <Esc><c-]><CR>
map <F3> <c-]><CR>
nmap <F4> :call ToggleSpell()<CR>
imap <F4> <Esc>:call ToggleSpell()<CR>a
" Prepare a :substitute command using the current word or the selected text:
vnoremap <F6> y:%s/\<<C-r>"\>//gc<Left><Left><Left>
nmap <F6> y:%s/\<<C-r>=expand("<cword>")<CR>\>//gc<Left><Left><Left>
map <F7> :call OpenInTerminal()<CR><CR>
" search for the keyword under the cursor in the current directory using the 'grep' command
nnoremap <F8> :grep <C-R><C-W> *<CR>
map <S-F8> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --exclude=*.html .<CR>
nnoremap <silent> <F9> :TlistToggle<CR>
map <S-F9> :set wrap!<CR> " toggle wrap lines
nnoremap <F10> :GundoToggle<CR>
nnoremap <S-F11> g- 
nnoremap <S-F12> g+ 
" highlight current word with <F12> and on mouse click
nnoremap <LeftRelease> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
inoremap <LeftRelease> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
noremap <F12> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
inoremap <F12> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
nnoremap <silent> <F11> :YRShow<CR>

vmap // y/<C-R>"<CR> " search for visually highlighted text
" use ghc functionality for haskell files
au BufEnter *.hs compiler ghc
function! GhciMake()
   cd %:h
   set makeprg=ghci\ %
   make
endfunction
function! GetVisualSelection()
  try
    let a_save = @a
    normal! gv"ay
    echo @a
    return @a
  finally
    let @a = a_save
  endtry
endfunction

function EvaluateInGhc() range
  let current = GetVisualSelection()
  let result = system('ghc -e '.shellescape(current))
  call setline(".", result)
endfunction
vmap <leader>e :call EvaluateInGhc()<CR>$x<esc>0
" quick way to escape from insert mode
inoremap jj <ESC>

" Spell check
function! ToggleSpell()
    if !exists("b:spell")
        setlocal spell spelllang=en_us
        let b:spell = 1
    else
        setlocal nospell
        unlet b:spell
    endif
endfunction
function! SwitchWindowKeepCurrentDir()
  let current = getcwd()
  wincmd W
  cd `=current`
endfunction

function! RakeCommand(command)
  cexpr system("rake " . a:command)
  cw " show quickfix window already
endfunction
command! -nargs=+ -complete=file Rake call RakeCommand(<q-args>)
" use ack to search in files
function! AckGrep(command)
  " execute 'NERDTreeToggle' 
  cexpr system("ack " . a:command)
  " execute 'NERDTreeToggle' 
  " wincmd l
  cw " show quickfix window already
endfunction
command! -nargs=+ -complete=file Ack call AckGrep(<q-args>)

" prompt for opening files in the same dir as the current buffer's file.
if has("unix")
  let g:os_specific_delimiter="/"
else
  let g:os_specific_delimiter="\\"
endif
map ,e :e <C-R>=expand("%:p:h") . g:os_specific_delimiter <CR>
"Vertical split then hop to new buffer
nnoremap ,v :vsp<CR>^W^W<CR>
nnoremap ,h :split<CR>^W^W<CR>
nnoremap ,rc :e ~/.vim/_vimrc_universal <CR>
nnoremap <silent> ,rr :QuickRun -mode n<CR>
vnoremap <silent> ,rr :QuickRun -mode v<CR>
nnoremap <silent>,, :FSHere<cr>
vnoremap <silent>,, :FSHere<cr>
nnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
vnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
"Make current window the only one
nnoremap ,O :onlyR>:tabo<CR>
nnoremap ,o :only<CR>
nnoremap <silent>,m :cd %:p:h<CR> :execute 'make'<CR>
nnoremap ,u :MRU<CR>
" set current dir to that of current file
map ,cd :call ToCurrentDir()<CR>
noremap ,d :execute 'NERDTreeToggle ' . getcwd()<CR><C-W><C-W><CR>
noremap ,f :execute 'NERDTreeFind'<CR> 
noremap <leader>f :execute 'NERDTreeFind'<CR> 
function! ToCurrentDir()
  cd %:p:h
  :pwd
endfunction 

map <leader>a :Ack<space>
nmap<leader>x <Plug>ToggleAutoCloseMappings
map <leader>r :Rake<space>
nmap<leader>l :set list!<CR>

" create html from text
function! Text2html()
  runtime! syntax/2html.vim :convert txt to html
endfunction 
command! Txt2html :call Text2html()

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
      \ | wincmd p | diffthis
endif
if has("autocmd")
  augroup mkd
    autocmd BufRead *.mkd,*.md,*.markdown  set ai formatoptions=tcroqn2 comments=n:&gt;
  augroup END
  augroup hs
    autocmd bufenter *.hs,*.lhs map <F5> :call OpenInGhci()<CR><CR>
    autocmd bufenter *.hs,*.lhs setlocal ts=2 sts=2 sw=2 expandtab
  augroup END
  augroup lua
  setlocal mp=lua\ % ts=2 sts=2 sw=2 noexpandtab
  " autocmd BufRead,BufNewFile *.lua set iskeyword+=.,:
    autocmd bufenter *.lua map <F5> :call OpenWithLua()<CR><CR>
  augroup END
  autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
  autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
  augroup js
      setlocal ts=2 sts=2 sw=2 expandtab
      set makeprg=jslint\ %
      setlocal efm=%f:%l:%c:%m
  augroup END

  autocmd FileType c,cpp setlocal ts=4 sts=4 sw=4 expandtab
  autocmd BufRead,BufNewFile *.rb set iskeyword+=?,!
  " Treat .rss files as XML
  autocmd BufNewFile,BufRead *.rss setfiletype xml
endif

