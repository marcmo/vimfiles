set nocompatible                " make Vim behave in a more useful way, less vi compatible
filetype off                    " required!
set rtp+=~/.vim/bundle/vundle/  " let Vundle manage Vundle
call vundle#rc()

Bundle 'gmarik/vundle'
Bundle 'L9'
Bundle 'tpope/vim-fugitive'
Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-repeat'
Bundle 'godlygeek/tabular'
Bundle 'tomtom/tcomment_vim'
Bundle 'scrooloose/nerdtree'
Bundle 'digitaltoad/vim-jade'
Bundle 'thinca/vim-quickrun'
Bundle 'sjl/gundo.vim'
Bundle 'msanders/snipmate.vim'
Bundle 'kien/ctrlp.vim'
Bundle 'Shougo/neocomplcache'
Bundle 'osyo-manga/neocomplcache-clang_complete'
Bundle 'Rip-Rip/clang_complete'
Bundle 'Raimondi/delimitMate'
Bundle 'derekwyatt/vim-fswitch'
Bundle 'godlygeek/csapprox'
Bundle 'sessionman.vim'
Bundle 'altercation/vim-colors-solarized'
Bundle 'veloce/vim-aldmeris'
Bundle 'bufkill.vim'
Bundle 'BufOnly.vim'
Bundle 'taglist.vim'
Bundle 'matchit.zip'
Bundle 'mru.vim'
Bundle 'eagletmt/ghcmod-vim'
Bundle 'dag/vim2hs'
Bundle 'Shougo/vimproc'
Bundle 'ujihisa/neco-ghc'
Bundle 'marcmo/haskellmode-vim'
Bundle 'AndrewRadev/switch.vim'

filetype plugin indent on           " required!

" UI Stuff {
    syntax on
    set background=dark
    if filereadable(expand("~/.vim/bundle/vim-aldmeris/colors/aldmeris.vim"))
      let g:aldmeris_termcolors = "tango"
      colorscheme aldmeris
    elseif
      filereadable(expand("~/.vim/bundle/vim-colors-solarized/colors/solarized.vim"))
      colorscheme solarized
    endif
    if has('gui_running')
      set guitablabel=%t            " only display the filename not the path
      set guioptions-=m             " remove [m]enubar
      set guioptions-=T             " remove [T]oolbar
      set cursorline                " highlight the screen line of the cursor
    else
      set t_Co=256
    endif
    if has('statusline')
      set laststatus=2                         " always show statusline
      set statusline=%<%f\                     " Filename
      set statusline+=%w%h%m%r                 " Options
      set statusline+=%{fugitive#statusline()} " Git Hotness
      set statusline+=\ [%{&ff}/%Y]            " filetype
      set statusline+=\ [%{getcwd()}]          " current dir
      set statusline+=%=%-14.(%l,%c%V%)\ %p%%  " Right aligned file nav info
    endif
    if has('cmdline_info')
      set ruler                     " show the cursor position all the time
      set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " a ruler on steroids
      set showcmd                   " show (partial) command in the last line of the screen
    endif
" }
" basic settings {
    set laststatus=2
    set wildignore+=*.o,*.obj,*.o.d,.git,*.a,*.d
    set nofoldenable                " disable folding
    set showmode                    " always show what mode we're currently editing in
    set nowrap                      " don't wrap lines
    set tabstop=2                   " a tab is 2 spaces by default
    set softtabstop=2               " when hitting <BS>, pretend like a tab is removed, even if spaces
    set expandtab                   " expand tabs default
    set shiftwidth=2                " number of spaces to use for autoindenting
    set shiftround                  " use multiple of shiftwidth when indenting with '<' and '>'
    set backspace=indent,eol,start  " allow backspacing over everything in insert mode
    set autoindent                  " always set autoindenting on
    set copyindent                  " copy the previous indentation on autoindenting
    set ignorecase                  " ignore case when searching
    set smartcase                   " ignore case if all lowercase, otherwise case-sensitive
    set smarttab                    " insert tabs on the start of a line according to shiftwidth
    set scrolloff=3                 " keep off the edges of the screen when scrolling
    set virtualedit=block           " allow virtual editing in Visual block mode.
    set winminheight=0              " windows can be 0 line high
    set hlsearch                    " highlight search terms
    set incsearch                   " show search matches as you type
    set completeopt=longest,menuone,preview
    set wildmode=longest:full       " bash like filename completion
    set wildmenu                    " show possible completions for filenames
    set hidden
    set noswapfile                  " disable swapfiles
    set history=1000                " keep 1000 lines of command line history
    set smartindent                " do smart autoindenting when starting a new line
    set vb                         " visual beep
    set autoread                   " reload file if permissions change due to BufWritePost below
    set autowrite                  " write file to disk on :make, :!, :first, :next
    set gcr=n:blinkon0             " turn of blinking cursor in normal mode
" }
" general utilities {
    " quick way to escape from insert mode
    inoremap jj <ESC>
    " use :w!! to write to a file using sudo
    cmap w!! %!sudo tee > /dev/null %
    nmap<leader>l :set list!<CR>
    " Yank from the cursor to the end of the line, to be consistent with C and D.
    nnoremap Y y$
    " leave the cursor at the point where it was before editing started
    nmap . .`[
    map <F7> :call OpenInTerminal()<CR><CR>
    " Go to newer/older text state
    nnoremap <S-F11> g-
    nnoremap <S-F12> g+
    " Wrapped lines goes down/up to next row, rather than next line in file.
    nnoremap j gj
    nnoremap k gk
    nnoremap ,rc :e ~/.vim/_vimrc_universal <CR>
    nnoremap ,bc :e ~/.bashrc <CR>
    " move lines up and down
    nnoremap <M-Down> mz:m+<CR>`z==
    nnoremap <M-Up> mz:m-2<CR>`z==
    inoremap <M-Down> <Esc>:m+<CR>==gi
    inoremap <M-Up> <Esc>:m-2<CR>==gi
    vnoremap <M-Down> :m'>+<CR>gv=`<my`>mzgv`yo`z
    vnoremap <M-Up> :m'<-2<CR>gv=`>my`<mzgv`yo`z
    " trailing whitespaces {
        " highlight end of line whitespace as Error
        hi link ExtraWhitespace Error
        augroup whitespaces
          autocmd BufNewFile,BufRead,InsertLeave * match ExtraWhitespace /\s\+$/
          " except the line I am typing on
          autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
          nnoremap <Leader>c :call ClearWhitespaces()<CR>
        augroup END
    " }
    " directories and files {
        map ,cd :call SetWorkingDirToCurrentDir()<CR>
        " climb up one directory level
        map <leader>u :cd ..<CR>:pwd<CR>
        " Some helpers to edit mode (http://vimcasts.org/e/14)
        cnoremap %% <C-R>=expand('%:h').'/'<cr>
        map <leader>ew :e %%
        map <leader>es :sp %%
        map <leader>ev :vsp %%
        map <leader>et :tabe %%
        " prompt for opening files in the same dir as the current buffer's file.
        if has("unix")
          let g:os_specific_delimiter="/"
        else
          let g:os_specific_delimiter="\\"
        endif
        map ,e :e <C-R>=expand("%:p:h") . g:os_specific_delimiter <CR>
    " }
    " search and substitution {
        " use normal regexes in search
        nnoremap / /\v
        vnoremap / /\v
        " search for the keyword under the cursor in the current directory using the 'grep' command
        nnoremap <F8> :grep <C-R><C-W> *<CR>
        " search for visually highlighted text
        vmap // y/<C-R>"<CR>
        " Prepare a :substitute command using the current word or the selected text:
        vnoremap <F6> y:%s/\<<C-r>"\>//gc<Left><Left><Left>
        nmap <F6> y:%s/\<<C-r>=expand("<cword>")<CR>\>//gc<Left><Left><Left>
    " }
    " movement {
        " jump back and forth between the last 2 files
        inoremap <C-Tab> <Esc>:e#<CR>
        noremap <C-Tab> :e#<CR>
        imap <C-S-Tab> <Esc> :bp<CR>
        map <C-S-Tab> :bp<CR>
        " jump to next/previous quickfix
        nmap <F4> :cn<CR>
        imap <F4> <Esc>:cn<CR>a
        nmap <S-F4> :cp<CR>
        imap <S-F4> <Esc>:cp<CR>a
    " }
    " hippie occurrence {
        " highlight current word with <F12> and on mouse click
        nnoremap <LeftRelease> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
        inoremap <LeftRelease> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
        noremap <F12> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
        inoremap <F12> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
    " }
    " window handling {
        set splitbelow splitright " Create split windows in more intuitive places
        " [v]ertical or [h]orizontal split then hop to new buffer
        nnoremap ,v :vsp<CR>^W^W<CR>
        nnoremap ,h :split<CR>^W^W<CR>
        nnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
        vnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
        "Make current window the only one
        nnoremap ,o :only<CR>
    " }
" }
" programming {
      nnoremap <silent>,m :execute 'make'<CR>
    " formatting {
        if has("autocmd")
          autocmd BufNewFile,BufRead *.cpp,*.c,*.h set formatprg=astyle\ -A1sYHjk1
        endif
        " format complete file and return to starting position using mark 'b'
        nnoremap <Leader>f mbgggqG`b
    " }
    " taglist {
        nnoremap <silent> <F9> :TlistToggle<CR>
    " }
    " ctags {
        set tags=tags;$HOME
        " Open the definition in a vertical split
        map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
        " lookup symbol in tags file
        imap <F3> <Esc><c-]><CR>
        map <F3> <c-]><CR>
        " jump to next tag
        nmap <S-F3> :tn<CR>
        imap <S-F3> <Esc>:tn<CR>a
        map <S-F8> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --exclude=*.html .<CR>
    " }
    " clang {
        let g:clang_auto_select=1
        let g:clang_complete_auto=1
        let g:clang_complete_copen=1
        let g:clang_snippets=1
        let g:clang_snippets_engine = "snipmate"
        let g:clang_exec="clang"
        let g:clang_user_options=""
        let g:clang_auto_user_options="path, .clang_complete"
        let g:clang_use_library=1
        let g:clang_library_path="/usr/local/lib"
        let g:clang_sort_algo="priority"
        let g:clang_complete_macros=1
        let g:clang_complete_patterns=0
        nnoremap <Leader>q :call g:ClangUpdateQuickFix()<CR>
    " }
    " fswitch {
        let g:fsnonewfiles=1
        let g:fswitchnonewfiles=1
        " Create the destination path by substituting any 'include' string from the pathname with 'src'
        let b:fswitchlocs = 'reg:/include/src/'
        if has("autocmd")
          augroup mycppfiles
            autocmd!
            autocmd BufEnter *.h let b:fswitchdst  = 'cpp,cc,C'
            autocmd BufEnter *.h let b:fswitchlocs = 'reg:/include/src/,reg:/include.*/src/,..'
            autocmd BufEnter *.c  let b:fswitchdst  = 'h'
            autocmd BufEnter *.c  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include'
            autocmd BufEnter *.cpp  let b:fswitchdst  = 'h'
            autocmd BufEnter *.cpp  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include,include'
          augroup END
        endif
        nnoremap <silent>,, :FSHere<cr>
        vnoremap <silent>,, :FSHere<cr>
    " }
    " switch.vim {
        nnoremap - :Switch<cr>
    " }
    " quickrun {
        let g:quickrun_config = {}
        let g:quickrun_config.haskell = {'eval' : 1 }
        let g:quickrun_config.c = {'type' :
        \     executable('clang')          ? 'c/clang' :
        \     executable('gcc')            ? 'c/gcc' : ''}
        nnoremap <silent> ,rr :QuickRun -mode n<CR>
        vnoremap <silent> ,rr :QuickRun -mode v<CR>
    " }
    " vim2hs {
        let g:haskell_conceal = 0
    " }
    " ghcmod-vim {
        let g:ghcmod_hlint_options = ['--ignore=Use camelCase', '--ignore=Top-level binding $']
        let g:ghcmod_ghc_options = ['-fno-warn-missing-signatures','-fno-warn-type-defaults']
        autocmd BufWritePost *.hs GhcModCheckAndLintAsync
        autocmd bufenter *.hs,*.lhs nnoremap <buffer> ,gh :GhcModType<CR>
        autocmd bufenter *.hs,*.lhs nnoremap <buffer> ,gc :GhcModTypeClear<CR>
    " }
    " haskellmode-vim {
        let hs_highlight_delimiters = 1 " Highlight delimiter characters
        let hs_highlight_boolean = 1 " Treat True and False as keywords.
        let hs_highlight_types = 1 " Treat names of primitive types as keywords.
        let hs_highlight_more_types = 1 " Treat names of other common types as keywords.
        autocmd BufWritePost *.hs GHCReload
        autocmd BufEnter *.hs compiler ghc
    " }
    " haskell {
        " use ghc functionality for haskell files
        function! EvaluateInGhc() range
          let current = GetVisualSelection()
          let result = system('ghc -e '.shellescape(current))
          call setline(".", result)
        endfunction
        vmap <leader>e :call EvaluateInGhc()<CR>$x<esc>0
        if has("autocmd")
          augroup hs
            autocmd bufenter *.hs,*.lhs map <F5> :call OpenInGhci()<CR><CR>
            autocmd bufenter *.hs,*.lhs setlocal ts=2 sts=2 sw=2 expandtab
          augroup END
        endif
    " }
    " javascript {
        if has("autocmd")
          augroup js
              setlocal ts=2 sts=2 sw=2 expandtab
              set makeprg=jslint\ %
              setlocal efm=%f:%l:%c:%m
          augroup END
        endif
    " }
    " lua {
        if has("autocmd")
          augroup lua
            setlocal mp=lua\ % ts=2 sts=2 sw=2 noexpandtab
          " autocmd BufRead,BufNewFile *.lua set iskeyword+=.,:
            autocmd bufenter *.lua map <F5> :call OpenWithLua()<CR><CR>
          augroup END
        endif
    " }
" }
" neocomplcache {
    let g:acp_enableAtStartup = 0
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_force_overwrite_completefunc=1
    " let g:neocomplcache_disable_auto_complete = 1
    let g:neocomplcache_enable_camel_case_completion = 1
    let g:neocomplcache_enable_smart_case = 1
    let g:neocomplcache_enable_underbar_completion = 1
    let g:neocomplcache_min_syntax_length = 3
    let g:neocomplcache_enable_auto_delimiter = 1
    let g:neocomplcache_enable_auto_select = 1
    " <ctrl-space>: completion.
    inoremap <expr><c-space> neocomplcache#start_manual_complete()
    " SuperTab like snippets behavior.
    imap <expr><TAB> neocomplcache#sources#snippets_complete#expandable() ? "\<Plug>(neocomplcache_snippets_expand)" : pumvisible() ? "\<C-n>" : "\<TAB>"

    " Plugin key-mappings.
    imap <C-k>     <Plug>(neocomplcache_snippets_expand)
    smap <C-k>     <Plug>(neocomplcache_snippets_expand)
    inoremap <expr><C-g>     neocomplcache#undo_completion()
    inoremap <expr><C-l>     neocomplcache#complete_common_string()

    " <CR>: close popup
    " <s-CR>: close popup and save indent.
    inoremap <expr><CR>  pumvisible() ? neocomplcache#close_popup() : "\<CR>"
    inoremap <expr><s-CR> pumvisible() ? neocomplcache#close_popup() "\<CR>" : "\<CR>"
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplcache#close_popup()
    inoremap <expr><C-e>  neocomplcache#cancel_popup()

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    " Enable heavy omni completion.
    if !exists('g:neocomplcache_omni_patterns')
      let g:neocomplcache_omni_patterns = {}
    endif
    let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
    let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'

    " For snippet_complete marker.
    if has('conceal')
      set conceallevel=2 concealcursor=i
    endif
" }
" Session List {
    set sessionoptions=blank,buffers,curdir,folds,options,tabpages,winsize
    nmap ,sl :SessionList<CR>
    nmap ,ss :SessionSave<CR>
" }
" fugitiv {
    function! CloseFugitiveDiffAfterUsage()
      diffoff!
      close
      wincmd k
    endfunction
    autocmd BufReadPost fugitive://* set bufhidden=delete
    noremap ,k :call CloseFugitiveDiffAfterUsage()<CR>
" }
" mru {
    let MRU_Max_Entries = 200
    let MRU_Window_Height = 25
    " nnoremap ,u :MRU<CR>
" }
" ctrlp {
    let g:ctrlp_max_height = 25
    let g:ctrlp_custom_ignore = '^\.git$\|\.hg$\|\.svn$\|\.metadata$'
    let g:ctrlp_by_filename = 1
    let g:ctrlp_max_files = 30000
    let g:ctrlp_match_window_bottom = 0
    let g:ctrlp_match_window_reversed = 0
    let g:ctrlp_mruf_max = 200
    let g:ctrlp_mruf_default_order = 0
    let g:ctrlp_working_path_mode = 'a'
    nnoremap ,u :CtrlPMRU<CR>
    map <F1> :CtrlPBuffer<CR>
    imap <F1> <esc>:CtrlPBuffer<CR>
    map <S-F1> :CtrlPBufTagAll<CR>
    imap <S-F1> <esc>:CtrlPBufTagAll<CR>
    map <leader>t :CtrlP<CR>
" }
" Spell check {
    nmap <F5> :call ToggleSpell()<CR>
    imap <F5> <Esc>:call ToggleSpell()<CR>a
" }
" nerdtree {
    noremap ,d :execute 'NERDTreeToggle ' . getcwd()<CR><C-W><C-W><CR>
    noremap ,f :execute 'NERDTreeFind'<CR>
" }
" bufkill {
    nnoremap ,w :BD<CR>
" }
" gundo {
    nnoremap <F10> :GundoToggle<CR>
" }
" Rake {
    function! RakeCommand(command)
      cexpr system("rake " . a:command)
      cw " show quickfix window already
    endfunction
    command! -nargs=+ -complete=file Rake call RakeCommand(<q-args>)
    map <leader>r :Rake<space>
" }
" ack {
    function! AckGrep(command)
      cexpr system("ack-grep " . a:command)
      cw " show quickfix window already
    endfunction
    command! -nargs=+ -complete=file Ack call AckGrep(<q-args>)
    map <leader>a :Ack<space>-G ".*\.(c\|cpp\|h\|hs\|lua\|rb)$"<space>
" }

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made. (Only define it when not defined already.)
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
      \ | wincmd p | diffthis
endif
if has("autocmd")
  augroup mkd
    autocmd BufRead *.mkd,*.md,*.markdown  set ai formatoptions=tcroqn2 comments=n:&gt;
  augroup END
  autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
  autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType c,cpp,java setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType c,cpp setlocal iskeyword-=?,!
  augroup html
      setlocal ts=2 sts=2 sw=2 expandtab
      set makeprg=jslint\ %
      setlocal efm=%f:%l:%c:%m
  augroup END
  autocmd BufRead,BufNewFile *.rb set iskeyword+=?,!
  autocmd BufRead,BufNewFile *.rss setfiletype xml
endif
" helper functions {
    function! GetVisualSelection()
      try
        let a_save = @a
        normal! gv"ay
        echo @a
        return @a
      finally
        let @a = a_save
      endtry
    endfunction

    function! ToggleSpell()
      if !exists("b:spell")
        setlocal spell spelllang=en_us
        let b:spell = 1
      else
        setlocal nospell
        unlet b:spell
      endif
    endfunction

    function! SwitchWindowKeepCurrentDir()
      let current = getcwd()
      wincmd W
      cd `=current`
    endfunction

    function! SetWorkingDirToCurrentDir()
      cd %:p:h
      :pwd
    endfunction

    " create html from text
    command! Txt2html :call Text2html()
    function! Text2html()
      runtime! syntax/2html.vim :convert txt to html
    endfunction

    " Remove trailing whitespaces and ^M chars on write
    command! ClearWhitespaces :call ClearWhitespaces()
    function! ClearWhitespaces()
      :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\s\\+$","","")'))
      if has("unix") " remove DOS style line endings
        :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\r\\+$","","")'))
      endif
    endfunction
" }

