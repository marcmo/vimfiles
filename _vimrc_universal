set nocompatible                " make Vim behave in a more useful way, less vi compatible
filetype off                    " required!

let s:vimconfig='.vim'
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

" essential plugins
Bundle 'gmarik/vundle'
Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-unimpaired'
Bundle 'godlygeek/tabular'
Bundle 'tomtom/tcomment_vim'
Bundle 'scrooloose/nerdtree'
Bundle 'mru.vim'
Bundle 'kien/ctrlp.vim'
Bundle 'Raimondi/delimitMate'
Bundle 'bufkill.vim'
Bundle 'BufOnly.vim'
Bundle 'matchit.zip'
Bundle 'Shougo/vimproc'
Bundle 'Shougo/neocomplcache'
Bundle 'Shougo/neosnippet'
Bundle 'Shougo/neosnippet-snippets'
Bundle 'veloce/vim-aldmeris'
Bundle 'bling/vim-airline'
Bundle 'godlygeek/csapprox'
Bundle 'Wombat'
" frequently used plugins
Bundle 'tpope/vim-repeat'
Bundle 'tpope/vim-fugitive'
Bundle 'thinca/vim-quickrun'
Bundle 'altercation/vim-colors-solarized'
Bundle 'derekwyatt/vim-fswitch'
Bundle 'ujihisa/neco-ghc'
Bundle 'marcmo/haskellmode-vim'
Bundle 'eagletmt/ghcmod-vim'
Bundle 'scrooloose/syntastic'
" seldom used plugins
Bundle 'majutsushi/tagbar'
Bundle "sk1418/QFGrep.git"
Bundle 'chrisbra/NrrwRgn.git'
Bundle 'sjl/gundo.vim'
Bundle 'AndrewRadev/switch.vim'
Bundle 'leafo/moonscript-vim'
Bundle 'tommcdo/vim-exchange'
Bundle 'thinca/vim-localrc'

filetype plugin indent on           " required!

" UI Stuff {
    syntax on
    set background=dark
    if has('gui_running')
      set guitablabel=%t            " only display the filename not the path
      set guioptions-=m             " remove [m]enubar
      set guioptions-=T             " remove [T]oolbar
      set guioptions-=rL            " remove all verical scrollbars
      set cursorline                " highlight the screen line of the cursor
      if filereadable(expand("~/.vim/bundle/vim-aldmeris/colors/aldmeris.vim"))
        let g:aldmeris_termcolors = "tango"
        colorscheme aldmeris
      elseif filereadable(expand("~/.vim/bundle/vim-colors-solarized/colors/solarized.vim"))
        colorscheme solarized
      endif
    else
      set t_Co=256                  " we want full colors in terminal
      colorscheme wombat
    endif
    if has('statusline')
      set laststatus=2                         " always show statusline
    endif
    if has('cmdline_info')
      set ruler                     " show the cursor position all the time
      set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " a ruler on steroids
      set showcmd                   " show (partial) command in the last line of the screen
    endif
" }
" basic settings {
    set wildignore+=*.o,*.obj,*.o.d,.git,*.a,*.s
    set nofoldenable                " disable folding
    set showmode                    " always show what mode we're currently editing in
    set nowrap                      " don't wrap lines
    set tabstop=2                   " a tab is 2 spaces by default
    set softtabstop=2               " when hitting <BS>, pretend like a tab is removed, even if spaces
    set expandtab                   " expand tabs default
    set shiftwidth=2                " number of spaces to use for autoindenting
    set shiftround                  " use multiple of shiftwidth when indenting with '<' and '>'
    set backspace=indent,eol,start  " allow backspacing over everything in insert mode
    set autoindent                  " always set autoindenting on
    set copyindent                  " copy the previous indentation on autoindenting
    set ignorecase                  " ignore case when searching
    set smartcase                   " ignore case if all lowercase, otherwise case-sensitive
    set smarttab                    " insert tabs on the start of a line according to shiftwidth
    set scrolloff=9                 " keep off the edges of the screen when scrolling
    set virtualedit=block           " allow virtual editing in Visual block mode.
    set winminheight=0              " windows can be 0 line high
    set hlsearch                    " highlight search terms
    set incsearch                   " show search matches as you type
    set completeopt=longest,menuone,preview
    set wildmode=longest:full       " bash like filename completion
    set wildmenu                    " show possible completions for filenames
    set hidden
    set noswapfile                  " disable swapfiles
    set history=1000                " keep 1000 lines of command line history
    set smartindent                 " do smart autoindenting when starting a new line
    set vb                          " visual beep
    set autoread                    " reload file if permissions change due to BufWritePost below
    set autowrite                   " write file to disk on :make, :!, :first, :next
    set gcr=n:blinkon0              " turn of blinking cursor in normal mode
    set synmaxcol=800               " Don't try to highlight lines longer than 800 characters.
    set lazyredraw                  " screen will not be redrawn while executing macros
" }
" general utilities {
    " paste in visual mode without updating the default register
    vnoremap p p:let @"=@0<CR>
    " quick way to escape from insert mode
    inoremap jj <ESC>
    inoremap kj <ESC>
    " use :w!! to write to a file using sudo
    cnoremap w!! %!sudo tee > /dev/null %
    nnoremap<leader>l :set list!<CR>
    nnoremap<leader>w :set wrap!<CR>

    " Yank from the cursor to the end of the line, to be consistent with C and D.
    nnoremap Y y$
    " leave the cursor at the point where it was before editing started
    nnoremap . .`[
    noremap <F7> :call OpenInTerminal()<CR><CR>
    " Go to newer/older text state
    nnoremap <S-F11> g-
    nnoremap <S-F12> g+
    " insert current date
    cnoremap <S-F10> <C-R>=strftime("%Y%m%d_%H%M")<CR>
    nnoremap <S-F10> "=strftime("%Y%m%d_%H%M")<CR>P
    inoremap <S-F10> <C-R>=strftime("%Y%m%d_%H%M")<CR>
    " Wrapped lines goes down/up to next row, rather than next line in file.
    nnoremap j gj
    nnoremap k gk
    execute 'nnoremap ,rc :vsplit ~/.vim/_vimrc_universal<CR>'
    nnoremap ,bc :e ~/.bashrc <CR>
    " move lines up and down
    nnoremap <M-Down> mz:m+<CR>`z==
    nnoremap <M-Up> mz:m-2<CR>`z==
    inoremap <M-Down> <Esc>:m+<CR>==gi
    inoremap <M-Up> <Esc>:m-2<CR>==gi
    vnoremap <M-Down> :m'>+<CR>gv=`<my`>mzgv`yo`z
    vnoremap <M-Up> :m'<-2<CR>gv=`>my`<mzgv`yo`z
    " scroll up and down
    nnoremap <C-e> 3<C-e>
    nnoremap <C-y> 3<C-y>
    " profiling
    nnoremap <silent> <leader>DD :exe ":profile start profile.log"<cr>:exe ":profile func *"<cr>:exe ":profile file *"<cr>
    nnoremap <silent> <leader>DQ :exe ":profile pause"<cr>:noautocmd qall!<cr>

    " trailing whitespaces {
        " highlight end of line whitespace as Error
        " hi link ExtraWhitespace Error
        hi ExtraWhitespace ctermbg=darkgrey guibg=brown
        augroup whitespaces " {
          autocmd!
          autocmd BufNewFile,BufRead,InsertLeave * match ExtraWhitespace /\s\+$/
          " except the line I am typing on
          autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
          nnoremap <Leader>c :call ClearWhitespaces()<CR>
        augroup END " }
    " }
    " directories and files {
        noremap ,cd :call SetWorkingDirToCurrentDir()<CR>
        " climb up one directory level
        noremap <leader>u :cd ..<CR>:pwd<CR>
        " Some helpers to edit mode (http://vimcasts.org/e/14)
        cnoremap %% <C-R>=expand('%:h').'/'<cr>
        noremap <leader>ew :e %%
        noremap <leader>es :sp %%
        noremap <leader>ev :vsp %%
        noremap <leader>et :tabe %%
        " prompt for opening files in the same dir as the current buffer's file.
        if has("unix")
          let g:os_specific_delimiter="/"
        else
          let g:os_specific_delimiter="\\"
        endif
        noremap ,e :e <C-R>=expand("%:p:h") . g:os_specific_delimiter <CR>
    " }
    " search and substitution {
        " use normal regexes in search
        nnoremap / /\v
        vnoremap / /\v
        " search for the keyword under the cursor in the current directory using the 'grep' command
        nnoremap <F8> :grep <C-R><C-W> *<CR>
        " search for visually highlighted text
        vnoremap // y/<C-R>"<CR>
        " Prepare a :substitute command using the current word or the selected text:
        vnoremap <F6> y:%s/\<<C-r>"\>//gc<Left><Left><Left>
        nnoremap <F6> y:%s/\<<C-r>=expand("<cword>")<CR>\>//gc<Left><Left><Left>
    " }
    " movement {
        " jump back and forth between the last 2 files
        inoremap <C-Tab> <Esc>:e#<CR>
        noremap <C-Tab> :e#<CR>
        inoremap <C-S-Tab> <Esc> :bp<CR>
        noremap <C-S-Tab> :bp<CR>
        " jump to next/previous quickfix
        nnoremap <F4> :cn<CR>
        inoremap <F4> <Esc>:cn<CR>a
        nnoremap <S-F4> :cp<CR>
        inoremap <S-F4> <Esc>:cp<CR>a
    " }
    " hippie occurrence {
        " highlight current word with <F12> and on mouse click
        nnoremap <LeftRelease> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
        inoremap <LeftRelease> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
        noremap <F12> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
        inoremap <F12> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
    " }
    " window handling {
        set splitbelow splitright " Create split windows in more intuitive places
        " [v]ertical or [h]orizontal split then hop to new buffer
        nnoremap ,v :vsp<CR>^W^W<CR>
        nnoremap ,h :split<CR>^W^W<CR>
        nnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
        vnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
        "Make current window the only one
        nnoremap ,o :only<CR>
    " }
" }
" programming {
      nnoremap <silent>,m :execute 'make'<CR>
    " formatting {
        augroup astyle " {
          autocmd!
          autocmd BufNewFile,BufRead *.cpp,*.c,*.h set formatprg=astyle\ -A1sYHjk1
        augroup END " }
        " format complete file and return to starting position using mark 'b'
        nnoremap <Leader>f mbgggqG`b
    " }
    " tcomment {
        let g:tcommentOptions = {'mixedindent':1}
    " }
    " tagbar {
        nnoremap <silent> <S-F9> :TagbarOpen<CR>
        let g:tagbar_autoclose=1
    " }
    " ctags {
        set tags=tags;$HOME
        " Open the definition in a vertical split
        noremap <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
        " lookup symbol in tags file
        inoremap <F3> <Esc><c-]><CR>
        noremap <F3> <c-]><CR>
        noremap <S-F8> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --exclude=*.html --exclude=*.s --exclude=docs .<CR>
        nnoremap <Leader>ht :! find . \| egrep '\.hs$' \| xargs hothasktags > tags<CR>
    " }
    " fswitch {
        let g:fsnonewfiles=1
        let g:fswitchnonewfiles=1
        " Create the destination path by substituting any 'include' string from the pathname with 'src'
        let b:fswitchlocs = 'reg:/include/src/'
        augroup mycppfiles " {
          autocmd!
          autocmd BufEnter *.h let b:fswitchdst  = 'cpp,CPP,cc,CC,c,C'
          autocmd BufEnter *.h let b:fswitchlocs = 'reg:/include/src/,reg:/include.*/src/,../src,src'
          autocmd BufEnter *.c  let b:fswitchdst  = 'h,H'
          autocmd BufEnter *.cpp,*.cc  let b:fswitchdst  = 'h,H'
          autocmd BufEnter *.cpp,*.cc,*.c  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include,include'
        augroup END " }
        nnoremap <silent>,, :FSHere<cr>
        vnoremap <silent>,, :FSHere<cr>
    " }
    " switch.vim {
        nnoremap - :Switch<cr>
    " }
    " syntastic {
        let g:syntastic_cpp_compiler = 'clang++'
        let g:syntastic_cpp_compiler_options = ' -std=c++11'
        let g:syntastic_error_symbol = '✗'
        let g:syntastic_warning_symbol = '>'
        let g:syntastic_check_on_wq = 0
        let g:syntastic_always_populate_loc_list = 1
        let g:syntastic_auto_loc_list = 1
        let g:syntastic_auto_jump = 2
        let g:syntastic_quiet_messages = { "level": "warnings",
                                        \ "type":  "style",
                                        \ "regex": 'Top-level binding with no type signature' }
    " }
    " quickrun {
        let g:quickrun_config = {}
        let g:quickrun_config.haskell = {'eval' : 1 }
        let g:quickrun_config.c = {'type' :
        \     executable('clang')          ? 'c/clang' :
        \     executable('gcc')            ? 'c/gcc' : ''}
        let g:quickrun_config.cpp = {
        \   'command': 'clang++',
        \   'cmdopt': '-std=c++11'
        \ }
        nnoremap <silent> ,rr :QuickRun -mode n<CR>
        vnoremap <silent> ,rr :QuickRun -mode v<CR>
    " }
    " ghcmod-vim {
        let g:ghcmod_hlint_options = ['--ignore=Use camelCase']
        let g:ghcmod_ghc_options = ['-fno-warn-missing-signatures','-fno-warn-type-defaults','-fno-warn-unused-binds']
        augroup ghcmod " {
          autocmd!
          " autocmd BufWritePost *.hs GhcModCheckAndLintAsync
          autocmd bufenter *.hs,*.lhs nnoremap <buffer> ,gh :GhcModType<CR>
          autocmd bufenter *.hs,*.lhs nnoremap <buffer> ,gc :GhcModTypeClear<CR>
        augroup END " }
    " }
    " haskellmode-vim {
        let hs_highlight_delimiters = 1 " Highlight delimiter characters
        let hs_highlight_boolean = 1 " Treat True and False as keywords.
        let hs_highlight_types = 1 " Treat names of primitive types as keywords.
        let hs_highlight_more_types = 1 " Treat names of other common types as keywords.
        augroup haskellmode " {
          autocmd!
          autocmd BufWritePost *.hs GHCReload
          autocmd BufEnter *.hs compiler ghc
        augroup END " }
    " }
    " haskell {
        " use ghc functionality for haskell files
        function! EvaluateInGhc() range
          let current = GetVisualSelection()
          let result = system('ghc -e '.shellescape(current))
          call setline(".", result)
        endfunction
        vnoremap <leader>e :call EvaluateInGhc()<CR>$x<esc>0

        augroup hs " {
          autocmd!
          autocmd bufenter *.hs,*.lhs noremap <F5> :call OpenInGhci()<CR><CR>
          autocmd bufenter *.hs,*.lhs setlocal ts=2 sts=2 sw=2 expandtab
        augroup END " }
    " }
    " javascript {
        augroup js " {
          autocmd!
          autocmd FileType html,javascript setlocal ts=2 sts=2 sw=2 expandtab
          autocmd FileType html,javascript setlocal makeprg=jslint\ % | setlocal efm=%f:%l:%c:%m
        augroup END " }
    " }
    " html {
        augroup html " {
          autocmd!
          let pandoc_pipeline  = "pandoc --from=html --to=markdown"
          let pandoc_pipeline .= " | pandoc --from=markdown --to=html"
          autocmd FileType html let &formatprg=pandoc_pipeline
        augroup END " }
    " }
    " lua {
        augroup lua " {
          autocmd!
          autocmd FileType lua setlocal mp=lua\ % ts=2 sts=2 sw=2 noexpandtab
          autocmd FileType lua noremap <F5> :call OpenWithLua()<CR><CR>
        augroup END " }
    " }
    " c++ {
        augroup cpp " {
          autocmd!
          autocmd bufenter *.cpp,*.h setlocal mp=clang++\ -std=c++11\ -I/Volumes/macbox_cs/dev/git/boost.git/\ -o\ %<\ %
          autocmd bufenter *.cpp nnoremap <F5> :update<CR>:call MakeCpp()<CR>
          autocmd bufenter *.cpp nnoremap <S-F5> :call UseTabsNotSpaces()<CR>
          autocmd QuickFixCmdPost [^l]* nested cwindow
          autocmd QuickFixCmdPost    l* nested lwindow
        augroup END " }
        " Save and make current file.o
        function! MakeCpp()
          let curr_dir = expand('%:h')
          if curr_dir == ''
            let curr_dir = '.'
          endif
          echo curr_dir
          execute 'lcd ' . curr_dir
          execute 'make'
          execute 'lcd -'
        endfunction
        function! UseTabsNotSpaces()
          set noexpandtab
          retab!
        endfunction
    " }
" }
" neocomplcache {
    let g:acp_enableAtStartup = 0
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_force_overwrite_completefunc=1
    " let g:neocomplcache_disable_auto_complete = 1
    let g:neocomplcache_enable_camel_case_completion = 1
    let g:neocomplcache_enable_smart_case = 1
    let g:neocomplcache_enable_underbar_completion = 1
    let g:neocomplcache_min_syntax_length = 3
    let g:neocomplcache_enable_auto_delimiter = 1
    let g:neocomplcache_enable_auto_select = 1
    " <ctrl-space>: completion.
    inoremap <expr><c-space> neocomplcache#start_manual_complete()
    " SuperTab like snippets behavior.
    inoremap <expr><TAB> neocomplcache#sources#snippets_complete#expandable() ? "\<Plug>(neocomplcache_snippets_expand)" : pumvisible() ? "\<C-n>" : "\<TAB>"

    " Plugin key-mappings.
    inoremap <C-k>     <Plug>(neocomplcache_snippets_expand)
    snoremap <C-k>     <Plug>(neocomplcache_snippets_expand)
    inoremap <expr><C-g>     neocomplcache#undo_completion()
    inoremap <expr><C-l>     neocomplcache#complete_common_string()

    " <CR>: close popup
    " <s-CR>: close popup and save indent.
    inoremap <expr><CR>  pumvisible() ? neocomplcache#close_popup() : "\<CR>"
    inoremap <expr><s-CR> pumvisible() ? neocomplcache#close_popup() "\<CR>" : "\<CR>"
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplcache#close_popup()
    inoremap <expr><C-e>  neocomplcache#cancel_popup()

    augroup neocompl " {
      autocmd!
    " Enable omni completion.
      autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
      autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
      autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
      autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
      autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
    augroup END " }

    " Enable heavy omni completion.
    if !exists('g:neocomplcache_omni_patterns')
      let g:neocomplcache_omni_patterns = {}
    endif
    " let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
    " let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'

    " For snippet_complete marker.
    if has('conceal')
      set conceallevel=2 concealcursor=i
    endif
" }
" neosnippet {
    imap <C-k>     <Plug>(neosnippet_expand_or_jump)
    smap <C-k>     <Plug>(neosnippet_expand_or_jump)

    " SuperTab like snippets behavior.
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
" }
" airline {
    let g:airline_powerline_fonts=1   " make sure powerline font is installed
" }
" fugitiv {
    function! CloseFugitiveDiffAfterUsage()
      diffoff!
      close
      wincmd k
    endfunction
    autocmd BufReadPost fugitive://* set bufhidden=delete
    noremap ,k :call CloseFugitiveDiffAfterUsage()<CR>
" }
" mru {
    let MRU_Max_Entries = 200
    let MRU_Window_Height = 25
    " nnoremap ,u :MRU<CR>
" }
" ctrlp {
    let g:ctrlp_max_height = 25
    let g:ctrlp_custom_ignore = '\v[\/]\.(git|hg|svn|d|metadata)$|^tags$'
    let g:ctrlp_by_filename = 1
    let g:ctrlp_max_files = 50000
    let g:ctrlp_match_window_bottom = 0
    let g:ctrlp_match_window_reversed = 0
    let g:ctrlp_mruf_max = 200
    let g:ctrlp_mruf_default_order = 0
    let g:ctrlp_working_path_mode = 0
    let g:ctrlp_follow_symlinks = 1
    nnoremap ,u :CtrlPMRU<CR>
    noremap <F1> :CtrlPBuffer<CR>
    inoremap <F1> <esc>:CtrlPBuffer<CR>
    noremap <S-F1> :CtrlPBufTagAll<CR>
    inoremap <S-F1> <esc>:CtrlPBufTagAll<CR>
    noremap <leader>t :CtrlP<CR>
" }
" Spell check {
    nnoremap <F9> :call ToggleSpell()<CR>
    inoremap <F9> <Esc>:call ToggleSpell()<CR>a
" }
" nerdtree {
    noremap ,d :execute 'NERDTreeToggle ' . getcwd()<CR><C-W>b
    noremap ,f :execute 'NERDTreeFind'<CR>
    let NERDTreeShowHidden=1  " display hidden files by default
    let NERDTreeQuitOnOpen = 1 " close NERDTree window when opening a file
" }
" bufkill {
    nnoremap ,w :BD<CR>
" }
" gundo {
    nnoremap <F10> :GundoToggle<CR>
" }
" Rake {
    function! RakeCommand(command)
      cexpr system("rake " . a:command)
      cw " show quickfix window already
    endfunction
    command! -nargs=+ -complete=file Rake call RakeCommand(<q-args>)
    noremap <leader>r :Rake<space>
" }
" ack {
    function! AckGrep(command)
      cexpr system("ack " . a:command)
      cw " show quickfix window already
    endfunction
    command! -nargs=+ -complete=file Ack call AckGrep(<q-args>)
    noremap <leader>a :Ack --type=
" }

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made. (Only define it when not defined already.)
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
      \ | wincmd p | diffthis
endif
augroup FTCheck " {
  autocmd!
  autocmd BufRead,BufNewFile *.mkd,*.md,*.markdown  set ai tw=100 fo=tcroqn2 comments=n:&gt; ft=markdown
  autocmd BufRead *.proto set ft=proto
  autocmd BufRead,BufNewFile *.rb set iskeyword+=?,!
  autocmd BufRead,BufNewFile *.rss setfiletype xml
augroup END " }
augroup FTOptions " {
  autocmd!
  autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
  autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType c,cpp,java setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType c,cpp setlocal iskeyword-=?,!
  autocmd FileType hs setlocal iskeyword-=.
  autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType qf wincmd J | setlocal wrap linebreak
augroup END " }
" move through camelcase words {
    "" Use one of the following to define the camel characters.
    " Stop on capital letters.
    " let g:camelchar = "A-Z"
    " Also stop on numbers.
    " let g:camelchar = "A-Z0-9"
    " Include '.' for class member, ',' for separator, ';' end-statement,
    " and <[< bracket starts and "'` quotes.
    let g:camelchar = "A-Z0-9.,;:{([`'\""
    nnoremap <silent><C-Left> :<C-u>call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%^','bW')<CR>
    nnoremap <silent><C-Right> :<C-u>call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%$','W')<CR>
    inoremap <silent><C-Left> <C-o>:call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%^','bW')<CR>
    inoremap <silent><C-Right> <C-o>:call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%$','W')<CR>
    vnoremap <silent><C-Left> :<C-U>call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%^','bW')<CR>v`>o
    vnoremap <silent><C-Right> <Esc>`>:<C-U>call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%$','W')<CR>v`<o
" }
" helper functions {
    function! GetVisualSelection()
      try
        let a_save = @a
        normal! gv"ay
        echo @a
        return @a
      finally
        let @a = a_save
      endtry
    endfunction

    function! ToggleSpell()
      if !exists("b:spell")
        setlocal spell spelllang=en_us
        let b:spell = 1
      else
        setlocal nospell
        unlet b:spell
      endif
    endfunction

    function! SwitchWindowKeepCurrentDir()
      let current = getcwd()
      wincmd W
      cd `=current`
    endfunction

    function! SetWorkingDirToCurrentDir()
      cd %:p:h
      :pwd
    endfunction

    " create html from text
    command! Txt2html :call Text2html()
    function! Text2html()
      runtime! syntax/2html.vim :convert txt to html
    endfunction

    " Remove trailing whitespaces and ^M chars on write
    command! ClearWhitespaces :call ClearWhitespaces()
    function! ClearWhitespaces()
      :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\s\\+$","","")'))
      if has("unix") " remove DOS style line endings
        :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\r\\+$","","")'))
      endif
    endfunction

    " replace german Umlauts
    command! UmlautCleanup :call ReplaceUmlauts()
    function! ReplaceUmlauts()
      let s:line = line(".")
      let s:column = col(".")
      let s:save_report = &report
      set report=99999
      let s:mapping = {"ä":"ae","ö":"oe","ü":"ue","Ä":"Ae","Ö":"Oe","Ü":"Ue","ß":"ss"}
      for i in items(s:mapping)
        execute "%s/".i[0]."/".i[1]."/eIg"
      endfor
      let &report=s:save_report
      unlet s:save_report
      call cursor(s:line,s:column)
      unlet s:line
      unlet s:column
    endfunction
" }

