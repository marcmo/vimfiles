set nocompatible                " make Vim behave in a more useful way, less vi compatible
filetype off                    " required!

let s:vimconfig='.vim'
call plug#begin('~/.vim/plugged')

" essential plugins
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tomtom/tcomment_vim'
Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeFind' }
Plug 'mru.vim'
Plug 'Raimondi/delimitMate'
Plug 'matchit.zip'
Plug 'Shougo/vimproc'
Plug 'Shougo/neocomplete'
Plug 'Shougo/neosnippet'
Plug 'Shougo/neosnippet-snippets'
Plug 'Shougo/unite.vim'
Plug 'Shougo/neomru.vim'
Plug 'bling/vim-airline'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': 'yes \| ./install' }
" frequently used plugins
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-fugitive'
Plug 'thinca/vim-quickrun'
Plug 'derekwyatt/vim-fswitch'
Plug 'eagletmt/ghcmod-vim', { 'for': 'haskell' }
Plug 'ujihisa/neco-ghc', { 'for': 'haskell' }
Plug 'scrooloose/syntastic'
Plug 'godlygeek/tabular'
Plug 'xolox/vim-lua-ftplugin', { 'for': 'lua' }
Plug 'xolox/vim-misc'
Plug 'embear/vim-localvimrc'
" seldom used plugins
Plug 'fatih/vim-go', { 'for': 'go' }
Plug 'wting/rust.vim', { 'for': 'rust' }
Plug 'elixir-lang/vim-elixir', { 'for': 'elixir' }
Plug 'junegunn/vim-easy-align'
Plug 'sk1418/QFGrep'
Plug 'mbbill/undotree'
Plug 'AndrewRadev/switch.vim'
Plug 'thinca/vim-localrc'
Plug 'severin-lemaignan/vim-minimap'
" colors & syntax highlighting
Plug 'ujihisa/unite-colorscheme'
Plug 'marcmo/essentialColors'
Plug 'godlygeek/csapprox'
Plug 'leafo/moonscript-vim'
call plug#end()

filetype plugin indent on           " required!

" UI Stuff {{{
    syntax on
    set background=dark
    if filereadable(expand("~/.vim/plugged/essentialColors/colors/aldmeris.vim"))
      colorscheme aldmeris
    elseif filereadable(expand("~/.vim/plugged/essentialColors/colors/solarized.vim"))
      colorscheme solarized
    endif
    set cursorline                " highlight the screen line of the cursor
    if has('mouse') | set mouse=a | endif " enable mouse in all modes
    if has('gui_running')
      set guitablabel=%t            " only display the filename not the path
      set guioptions-=m             " remove [m]enubar
      set guioptions-=T             " remove [T]oolbar
      set guioptions-=rL            " remove all verical scrollbars
    else
      set t_Co=256                  " we want full colors in terminal
    endif
    if has('statusline')
      set laststatus=2                         " always show statusline
    endif
    if has('cmdline_info')
      set ruler                     " show the cursor position all the time
      set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " a ruler on steroids
      set showcmd                   " show (partial) command in the last line of the screen
    endif
" }}}
" basic settings {{{
    set wildignore+=*.o,*.obj,*.o.d,.git,*.a,*.s
    set nofoldenable                " disable folding
    set showmode                    " always show what mode we're currently editing in
    set nowrap                      " don't wrap lines
    set tabstop=2                   " a tab is 2 spaces by default
    set softtabstop=2               " when hitting <BS>, pretend like a tab is removed, even if spaces
    set expandtab                   " expand tabs default
    set shiftwidth=2                " number of spaces to use for autoindenting
    set shiftround                  " use multiple of shiftwidth when indenting with '<' and '>'
    set backspace=indent,eol,start  " allow backspacing over everything in insert mode
    set autoindent                  " always set autoindenting on
    set copyindent                  " copy the previous indentation on autoindenting
    set ignorecase                  " ignore case when searching
    set smartcase                   " ignore case if all lowercase, otherwise case-sensitive
    set smarttab                    " insert tabs on the start of a line according to shiftwidth
    set scrolloff=9                 " keep off the edges of the screen when scrolling
    set virtualedit=block           " allow virtual editing in Visual block mode.
    set winminheight=0              " windows can be 0 line high
    set hlsearch                    " highlight search terms
    set incsearch                   " show search matches as you type
    set completeopt=longest,menuone,preview
    set wildmode=longest:full       " bash like filename completion
    set wildmenu                    " show possible completions for filenames
    set hidden
    set noswapfile                  " disable swapfiles
    set history=1000                " keep 1000 lines of command line history
    set smartindent                 " do smart autoindenting when starting a new line
    set vb                          " visual beep
    set autoread                    " reload file if permissions change due to BufWritePost below
    set autowrite                   " write file to disk on :make, :!, :first, :next
    set gcr=n:blinkon0              " turn of blinking cursor in normal mode
    set synmaxcol=800               " Don't try to highlight lines longer than 800 characters.
    set lazyredraw                  " screen will not be redrawn while executing macros
    set diffopt=vertical,context:4  " Start diff mode with vertical splits,context of 4 lines
    set diffopt+=iwhite
    " Time out on key codes but not mappings.
    set notimeout
    set ttimeout
    set ttimeoutlen=10
" }}}
" general utilities {{{
    inoremap <F1> <Esc>
    noremap <F1> :call MapF1()<CR>

    function! MapF1()
      if &buftype == "help"
        exec 'quit'
      else
        exec 'help'
      endif
    endfunction
    " select the last changed text (or the text that was just pasted)
    nnoremap gp `[v`]
    " Save when losing focus
    au FocusLost * :silent! wall
    " uppercase word just typed
    inoremap <C-u> <esc>mzgUiw`za
    " Source
    vnoremap <leader>S y:execute @@<cr>:echo 'Sourced selection.'<cr>
    nnoremap <leader>S ^vg_y:execute @@<cr>:echo 'Sourced line.'<cr>
    " Resize splits when the window is resized
    au VimResized * :wincmd =
    " paste in visual mode without updating the default register
    vnoremap p p:let @"=@0<CR>
    " quick way to escape from insert mode
    inoremap jj <ESC>
    inoremap kj <ESC>
    " use :w!! to write to a file using sudo
    cnoremap w!! w !sudo tee % >/dev/null
    nnoremap<leader>l :set list!<CR>
    nnoremap<leader>w :set wrap!<CR>

    " Select (charwise) the contents of the current line, excluding indentation.
    nnoremap vv ^vg_

    " Yank from the cursor to the end of the line, to be consistent with C and D.
    nnoremap Y y$
    " leave the cursor at the point where it was before editing started
    nnoremap . .`[
    noremap <F7> :call OpenInTerminal()<CR><CR>
    " Go to newer/older text state
    nnoremap <S-F11> g-
    nnoremap <S-F12> g+
    " insert current date
    cnoremap <S-F10> <C-R>=strftime("%Y%m%d-%H%M")<CR>
    nnoremap <S-F10> "=strftime("%Y%m%d-%H%M")<CR>P
    inoremap <S-F10> <C-R>=strftime("%Y%m%d-%H%M")<CR>
    vnoremap <S-F10> c<C-R>=strftime("%Y%m%d-%H%M")<CR><Esc>gv
    " Wrapped lines goes down/up to next row, rather than next line in file.
    nnoremap j gj
    nnoremap k gk
    nnoremap ,rc :e ~/.vim/_vimrc_universal<CR>
    nnoremap ,bc :e ~/.bashrc <CR>
    " move lines up and down
    nnoremap <M-Down> mz:m+<CR>`z==
    nnoremap <M-Up> mz:m-2<CR>`z==
    inoremap <M-Down> <Esc>:m+<CR>==gi
    inoremap <M-Up> <Esc>:m-2<CR>==gi
    vnoremap <M-Down> :m'>+<CR>gv=`<my`>mzgv`yo`z
    vnoremap <M-Up> :m'<-2<CR>gv=`>my`<mzgv`yo`z
    " scroll up and down
    nnoremap <C-e> 3<C-e>
    nnoremap <C-y> 3<C-y>
    " profiling
    nnoremap <silent> <leader>DD :exe ":profile start profile.log"<cr>:exe ":profile func *"<cr>:exe ":profile file *"<cr>
    nnoremap <silent> <leader>DQ :exe ":profile pause"<cr>:noautocmd qall!<cr>
    " Indent Guides {{{
        let g:indentguides_state = 0
        function! IndentGuides() " {{{
            if g:indentguides_state
                let g:indentguides_state = 0
                2match None
            else
                let g:indentguides_state = 1
                execute '2match IndentGuides /\%(\_^\s*\)\@<=\%(\%'.(0*&sw+1).'v\|\%'.(1*&sw+1).'v\|\%'.(2*&sw+1).'v\|\%'.(3*&sw+1).'v\|\%'.(4*&sw+1).'v\|\%'.(5*&sw+1).'v\|\%'.(6*&sw+1).'v\|\%'.(7*&sw+1).'v\)\s/'
            endif
        endfunction " }}}
        hi def IndentGuides guibg=#303030 ctermbg=234
        nnoremap <leader>I :call IndentGuides()<cr>
    " }}}
    " trailing whitespaces {{{
        " highlight end of line whitespace as Error (not for unite windows)
        " hi link ExtraWhitespace Error
        hi ExtraWhitespace ctermbg=darkgrey guibg=#707070
        augroup whitespaces " {{{
          autocmd!
          autocmd BufWinEnter * if &modifiable && &ft!='unite' | match ExtraWhitespace /\s\+$/ | endif
          autocmd InsertEnter * if &modifiable && &ft!='unite' | match ExtraWhitespace /\s\+\%#\@<!$/ | endif
          autocmd InsertLeave * if &modifiable && &ft!='unite' | match ExtraWhitespace /\s\+$/ | endif
          autocmd BufWinLeave * if &modifiable && &ft!='unite' | call clearmatches() | endif
          nnoremap <Leader>c :call ClearWhitespaces()<CR>
        augroup END " }}}
    " }}}
    " directories and files {{{
        augroup VimrcAutocmds
          autocmd!
          autocmd VimEnter * cd %:p:h
        augroup END
        noremap ,cd :call SetWorkingDirToCurrentDir()<CR>
        " climb up one directory level
        noremap <silent> <space>p :pwd<cr>
        noremap <leader>u :cd ..<CR>:pwd<CR>
        " prompt for opening files in the same dir as the current buffer's file.
        if has("unix")
          let g:os_specific_delimiter="/"
        else
          let g:os_specific_delimiter="\\"
        endif
        noremap ,e :e <C-R>=expand("%:p:h") . g:os_specific_delimiter <CR>
    " }}}
    " search and substitution {{{
        noremap <silent> <space><space> :noh<cr>:call clearmatches()<cr>
        " use normal regexes in search
        nnoremap / /\v
        vnoremap / /\v
        " search for the keyword under the cursor in the current directory using the 'grep' command
        nnoremap <F8> :grep <C-R><C-W> *<CR>
        " search for visually highlighted text
        vnoremap // y/<C-R>"<CR>
        " Prepare a :substitute command using the current word or the selected text:
        vnoremap <F6> y:%s/\v<<C-r>">//gc<Left><Left><Left>
        nnoremap <F6> y:%s/\v<<C-r>=expand("<cword>")<CR>>//gc<Left><Left><Left>
    " }}}
    " movement {{{
        " jump back and forth between the last 2 files
        noremap ,a :e#<CR>
        inoremap <C-S-Tab> <Esc> :bp<CR>
        noremap <C-S-Tab> :bp<CR>
        " jump to next/previous quickfix
        nnoremap <F4> :cn<CR>
        inoremap <F4> <Esc>:cn<CR>a
        nnoremap <S-F4> :cp<CR>
        inoremap <S-F4> <Esc>:cp<CR>a
    " }}}
    " hippie occurrence {{{
        " highlight current word with <F12> and on mouse click
        nnoremap <LeftRelease> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
        inoremap <LeftRelease> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
        noremap <F12> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
        inoremap <F12> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
    " }}}
    " window handling {{{
        set splitbelow splitright " Create split windows in more intuitive places
        " [v]ertical or [h]orizontal split then hop to new buffer
        nnoremap ,v :vsp<CR>^W^W<CR>
        nnoremap ,h :split<CR>^W^W<CR>
        nnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
        vnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
        "Make current window the only one
        nnoremap ,o :only<CR>
        "auto close the preview window when exiting insert mode
        autocmd InsertLeave * if pumvisible() == 0|pclose|endif
    " }}}
" localvimrc {{{
    let g:localvimrc_whitelist=expand("~") . "/dev/git/.*"
" }}}
" }}}
" programming {{{
      nnoremap <silent>,m :execute 'make'<CR>
    " formatting {{{
        augroup astyle " {{{
          autocmd!
          autocmd BufNewFile,BufRead *.cpp,*.c,*.h setlocal formatprg=astyle\ -A1sYHjk1STxC100
        augroup END " }}}
        " format complete file and return to starting position using mark 'b'
        nnoremap <Leader>f mbgggqG`b
        nnoremap ,t :call UseTabsNotSpaces()<CR>:w<CR>:set list!<CR>:echo "spaces->tabs"<CR>
        nnoremap ,s :call UseSpacesNotTabs()<CR>:w<CR>:echo "tabs->spaces"<CR>
    " }}}
    " tcomment {{{
        let g:tcommentOptions = {'mixedindent':1}
    " }}}
    " tagbar {{{
        nnoremap <silent> <S-F9> :TagbarOpen<CR>
        let g:tagbar_autoclose=1
    " }}}
    " ctags {{{
        set tags=tags;$HOME
        " Open the definition in a vertical split
        noremap <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
        " lookup symbol in tags file
        inoremap <F3> <Esc><c-]><CR>
        noremap <F3> <c-]>
        " use tpope's awesome ctags git hooks (see http://bit.ly/gitctags)
        noremap <S-F8> :!git ctags<CR>
        nnoremap <Leader>ht :! find . \| egrep '\.hs$' \| xargs hothasktags > tags<CR>
    " }}}
    " fswitch {{{
        let g:fsnonewfiles=1
        let g:fswitchnonewfiles=1
        " Create the destination path by substituting any 'include' string from the pathname with 'src'
        let b:fswitchlocs = 'reg:/include/src/'
        augroup mycppfiles " {{{
          autocmd!
          autocmd BufEnter *.h let b:fswitchdst  = 'cpp,CPP,cc,CC,c,C,hpp,HPP'
          autocmd BufEnter *.h let b:fswitchlocs = 'reg:/include/src/,reg:/include.*/src/,../src,src'
          autocmd BufEnter *.c,*.cpp,*.cc,*.hpp  let b:fswitchdst  = 'h,H'
          autocmd BufEnter *.cpp,*.cc,*.c,*.hpp  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include,include'
        augroup END " }}}
        nnoremap <silent>,, :FSHere<cr>
        vnoremap <silent>,, :FSHere<cr>
    " }}}
    " switch.vim {{{
        nnoremap - :Switch<cr>
    " }}}
    " syntastic {{{
        function! DebugSyntastic() " {{{
          if g:syntastic_debug == 1
            let g:syntastic_debug = 0
            echo "turn off syntastic debugging"
          else
            let g:syntastic_debug = 1
            let g:syntastic_debug_file = '~/syntastic.log'
            exe ':e ' . g:syntastic_debug_file
            echo "turn on syntastic debugging"
          endif
        endfunction " }}}
        noremap <silent> <leader>DS :call DebugSyntastic()<CR>
        let g:syntastic_cpp_compiler = 'clang++'
        let g:syntastic_cpp_compiler_options = ' -std=c++11'
        let g:syntastic_check_on_wq = 0
        let g:syntastic_error_symbol = '✗'
        let g:syntastic_warning_symbol = '>'
        let g:syntastic_always_populate_loc_list = 1
        let g:syntastic_auto_loc_list = 2
        let g:syntastic_auto_jump = 2
        let g:syntastic_quiet_messages = { "level": "warnings",
                                        \ "type":  "style",
                                        \ "regex": 'Top-level binding with no type signature' }
        let g:syntastic_ruby_checkers = ['mri', 'ruby_lint']
        let g:syntastic_haskell_checkers = ['hdevtools', 'hlint']
        let g:syntastic_mode_map = { 'mode': 'active', 'passive_filetypes': ['haskell','cpp'] }
        let g:syntastic_elixir_checkers = ['elixir']
        let g:syntastic_enable_elixir_checker = 1
        nnoremap <leader>s :w<CR> :SyntasticCheck<CR>
    " }}}
    " quickrun {{{
        let g:quickrun_config = {}
        let g:quickrun_config.haskell = {'eval' : 1 }
        let g:quickrun_config.c = {'type' :
        \     executable('clang')          ? 'c/clang' :
        \     executable('gcc')            ? 'c/gcc' : ''}
        let g:quickrun_config.cpp = {
        \   'command': 'clang++',
        \   'cmdopt': '-Iinclude -std=c++11'
        \ }
        nnoremap <silent> ,rr :QuickRun -mode n<CR>
        vnoremap <silent> ,rr :QuickRun -mode v<CR>
    " }}}
    " ghcmod-vim {{{
        let g:ghcmod_hlint_options = ['--ignore=Use camelCase']
        let g:ghcmod_ghc_options = ['-fno-warn-missing-signatures','-fno-warn-type-defaults','-fno-warn-unused-binds']
        augroup ghcmod " {{{
          autocmd!
          " autocmd BufWritePost *.hs GhcModCheckAndLintAsync
          autocmd bufenter *.hs,*.lhs nnoremap <buffer> ,gh :GhcModType<CR>
          autocmd bufenter *.hs,*.lhs nnoremap <buffer> ,gc :GhcModTypeClear<CR>
          autocmd bufenter *.hs,*.lhs nnoremap <silent> _T :GhcModTypeInsert<CR>:w<CR>
          autocmd bufenter *.hs,*.lhs nnoremap <silent> _I :GhcModType<CR>
          autocmd bufenter *.hs,*.lhs nnoremap <silent> _C :GhcModTypeClear<CR>
          autocmd bufenter *.hs,*.lhs nnoremap <silent> _X :GhcModCheckAndLintAsync<CR>
          autocmd bufenter *.hs,*.lhs nnoremap <silent> ,m :update<CR>:GhcModCheck<CR>
        augroup END " }}}
    " }}}
    " go {{{
        let g:go_bin_path = ""
    " }}}
    " haskell {{{
        " use ghc functionality for haskell files
        function! EvaluateInGhc() range " {{{
          let current = GetVisualSelection()
          let result = system('ghc -e '.shellescape(current))
          call setline(".", result)
        endfunction " }}}
        vnoremap <leader>e :call EvaluateInGhc()<CR>$x<esc>0

        augroup hs " {{{
          autocmd!
          autocmd bufenter *.hs,*.lhs noremap <F5> :call OpenInGhci()<CR><CR>
          autocmd bufenter *.hs,*.lhs setlocal ts=2 sts=2 sw=2 expandtab
          autocmd bufenter *.hs,*.lhs nnoremap <Leader>ht :! find . \| egrep '\.hs$' \| xargs hothasktags > tags<CR>
        augroup END " }}}
    " }}}
    " javascript {{{
        augroup js " {{{
          autocmd!
          autocmd FileType html,javascript setlocal ts=2 sts=2 sw=2 expandtab
          autocmd FileType html,javascript setlocal makeprg=jslint\ % | setlocal efm=%f:%l:%c:%m
        augroup END " }}}
    " }}}
    " lua {{{
        augroup lua " {{{
          autocmd!
          autocmd FileType lua setlocal mp=lua\ % ts=2 sts=2 sw=2 noexpandtab
          autocmd FileType lua noremap <F5> :call OpenWithLua()<CR><CR>
        augroup END " }}}
    " }}}
    " c++ {{{
        augroup cpp " {{{
          autocmd!
          autocmd bufenter *.cpp,*.c,*.h setlocal mp=clang++\ -std=c++11\ -Iinclude\ -I$HOME/dev/git/boost.git/\ -o\ %<\ %
          autocmd bufenter *.cpp,*.c nnoremap <F5> :update<CR>:call MakeCpp()<CR>
          autocmd bufenter *.cpp,*.c nnoremap <silent> ,m :update<CR>:call MakeCpp()<CR>
          autocmd BufRead,BufNewFile *.cpp set tw=100 fo=tcroql
          autocmd QuickFixCmdPost [^l]* nested cwindow
          autocmd QuickFixCmdPost    l* nested lwindow
        augroup END " }}}
        " Save and make current file.o
        function! MakeCpp() " {{{
          let curr_dir = expand('%:h')
          if curr_dir == ''
            let curr_dir = '.'
          endif
          echo curr_dir
          execute 'lcd ' . curr_dir
          execute 'make'
          execute 'lcd -'
        endfunction " }}}
        function! UseTabsNotSpaces() " {{{
          set noexpandtab
          retab!
        endfunction " }}}
        function! UseSpacesNotTabs() " {{{
          set expandtab
          retab!
        endfunction " }}}
    " }}}
" }}}
" neocomplete {{{
    let g:acp_enableAtStartup = 0
    let g:neocomplete#enable_at_startup = 1
    let g:neocomplete#force_overwrite_completefunc = 1
    let g:neocomplete#enable_camel_case = 1
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#sources#syntax#min_keyword_length = 3
    let g:neocomplete#enable_auto_delimiter = 1
    let g:neocomplete#enable_auto_select = 1
    " <ctrl-space>: completion...and since it is interpretet as Ctrl-@ in terminal vim, remap this as well
    inoremap <expr><C-space> neocomplete#start_manual_complete()
    imap <C-@> <C-Space>
    " Plugin key-mappings.
    " inoremap <C-k>     <Plug>(neocomplcache_snippets_expand)
    " snoremap <C-k>     <Plug>(neocomplcache_snippets_expand)
    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " <CR>: close popup
    " <s-CR>: close popup and save indent.
    inoremap <expr><CR>  pumvisible() ? neocomplete#close_popup() : "\<CR>"
    inoremap <expr><s-CR> pumvisible() ? neocomplete#close_popup() "\<CR>" : "\<CR>"
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y> neocomplete#close_popup()
    inoremap <expr><C-e> neocomplete#cancel_popup()

    augroup neocompl " {{{
      autocmd!
    " Enable omni completion.
      autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
      autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
      autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
      autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
      autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    augroup END " }}}

    " Enable heavy omni completion.
    if !exists('g:neocomplete#sources#omni#input_patterns')
      let g:neocomplete#sources#omni#input_patterns = {}
    endif

    " For snippet_complete marker.
    if has('conceal')
      set conceallevel=2 concealcursor=i
    endif
" }}}
" neosnippet {{{
    autocmd InsertLeave * NeoSnippetClearMarkers
    imap <C-k>     <Plug>(neosnippet_expand_or_jump)
    smap <C-k>     <Plug>(neosnippet_expand_or_jump)

    " SuperTab like snippets behavior.
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
" }}}
" airline {{{
    let g:airline_powerline_fonts=1   " make sure powerline font is installed
    let g:airline#extensions#whitespace#mixed_indent_algo = 1
" }}}
" fugitiv {{{
    function! CloseFugitiveDiffAfterUsage() " {{{
      diffoff!
      close
      wincmd k
    endfunction " }}}
    autocmd BufReadPost fugitive://* set bufhidden=delete
    noremap ,k :call CloseFugitiveDiffAfterUsage()<CR>
" }}}
" mru {{{
    let MRU_Max_Entries = 200
    let MRU_Window_Height = 25
" }}}
" vim-easy-align {{{
    " Start interactive EasyAlign in visual mode (e.g. vip<Enter>)
    vmap <Enter> <Plug>(EasyAlign)
    " Start interactive EasyAlign for a motion/text object (e.g. <Leader>aip)
    nmap <Leader>a <Plug>(EasyAlign)
" }}}
" Unite {{{
    if executable('ag')
      let g:unite_source_rec_async_command='ag --nocolor --nogroup --hidden -U ' .
        \ '--ignore ".hg" --ignore ".svn" --ignore ".git" --ignore ".bzr" -g ""'
      let g:unite_source_grep_command = 'ag'
      let g:unite_source_grep_default_opts = '-i --line-numbers --nocolor --nogroup --hidden -U ' .
        \  '--ignore "hg" --ignore ".svn" --ignore ".git" --ignore ".bzr" --ignore ".repo"'
      let g:unite_source_grep_recursive_opt = ''
    elseif executable('ack-grep')
      let g:unite_source_grep_command = 'ack-grep'
      let g:unite_source_grep_default_opts = '-i --no-heading --no-color -k -H'
      let g:unite_source_grep_recursive_opt = ''
    endif

    let g:unite_source_history_yank_enable = 1
    call unite#filters#matcher_default#use(['matcher_fuzzy'])
    call unite#filters#converter_default#use(['converter_tail'])

    call unite#custom#source('file_rec/async', 'ignore_pattern', join(['/\.repo$','/\.metadata$','\.d$','\.a$','\.o$','\.s$','tags$'], '\|'))
    call unite#custom#source('buffer,file,file_rec/async', 'sorters', 'sorter_rank')
    call unite#custom#source('buffer,file,file_rec/async,file_mru', 'matchers', ['converter_tail', 'matcher_default'])
    call unite#custom#source('buffer,file,file_rec/async,file_mru', 'converters', ['converter_file_directory'])

    noremap [unite] <Nop>
    map <Space> [unite]
    " nnoremap <silent> [unite]t :<C-u>Unite -no-split -buffer-name=files   -start-insert file_rec/async:!<cr>
    " nnoremap <silent> [unite]t  ==> see FZF section
    nnoremap <silent> [unite]T :<C-u>Unite -no-split -buffer-name=files   -start-insert file<cr>
    nnoremap <silent> ,u       :<C-u>Unite -no-split -buffer-name=mru     -start-insert file_mru<cr>
    nnoremap <silent> [unite]y :<C-u>Unite -no-split -buffer-name=yank    history/yank<cr>
    nnoremap <silent> [unite]e :<C-u>Unite -no-split -buffer-name=buffer  buffer<cr>
    nnoremap <silent> [unite]r :<C-u>Unite -buffer-name=register register<CR>

    nnoremap [unite]q :Unite grep:.:"-sG\.\(h\|c\|cpp\)$" -input=<C-r><C-w><CR>
    nnoremap [unite]w :UniteResume<CR>

    autocmd FileType unite call s:unite_settings()
    function! s:unite_settings() " {{{
      call clearmatches()
      imap <silent><buffer>       <C-j> <Plug>(unite_select_next_line)
      " map arrow Up and Down in normal mode
      nmap <silent><buffer><ESC>oA k
      nmap <silent><buffer><ESC>oB j
      imap <silent><buffer>       <C-k> <Plug>(unite_select_previous_line)
      imap <silent><buffer><expr> <C-x> unite#do_action('split')
      imap <silent><buffer><expr> <C-v> unite#do_action('vsplit')
      imap <silent><buffer><expr> <C-t> unite#do_action('tabopen')
      nmap <silent><buffer>       <ESC> <Plug>(unite_exit)
      imap <silent><buffer>       <C-c> <Plug>(unite_exit)
      nmap <silent><buffer>       <F5>  <Plug>(unite_redraw)
      imap <silent><buffer>       <F5>  <Plug>(unite_redraw)
    endfunction " }}}
" }}}
" FZF {{{
      command! FZFMru call fzf#run({
            \'source': v:oldfiles,
            \'sink' : 'e ',
            \'options' : '-m',
            \})
      " command-T like listing of all files in current directory
      nnoremap <silent> [unite]t :call fzf#run({
      \   'source':'find . \( \( -name .repo -a -type d \) ' .
      \   '-o \( -name "Debug_*" -a -type d \) \) -prune ' .
      \   '-o \( -name "*.d" -o -name "*.o" -o -name "*.a" \) -prune -o -type f -print',
      \   'sink':  'e ',
      \   'options':  '-m --reverse'
      \ })<CR>

      " Choose a color scheme with fzf
      nnoremap <silent> <Leader>C :call fzf#run({
      \   'source':
      \     map(split(globpath(&rtp, "colors/*.vim"), "\n"),
      \         "substitute(fnamemodify(v:val, ':t'), '\\..\\{-}$', '', '')"),
      \   'sink':     'colo',
      \   'options':  '+m --reverse',
      \   'left':     20,
      \   'launcher': 'xterm -geometry 20x30 -e bash -ic %s'
      \ })<CR>

      " search with ag
      function! s:ag_handler(lines)
        if len(a:lines) < 2 | return | endif

        let [key, line] = a:lines[0:1]
        let [file, line, col] = split(line, ':')[0:2]
        let cmd = get({'ctrl-x': 'split', 'ctrl-v': 'vertical split', 'ctrl-t': 'tabe'}, key, 'e')
        execute cmd escape(file, ' %#\')
        execute line
        execute 'normal!' col.'|zz'
      endfunction

      command! -nargs=1 Ag call fzf#run({
      \ 'source':  'ag --nogroup --column --color "'.escape(<q-args>, '"\').'"',
      \ 'sink*':    function('<sid>ag_handler'),
      \ 'options': '--ansi --expect=ctrl-t,ctrl-v,ctrl-x --no-multi --reverse',
      \ 'down':    '50%'
      \ })
      nnoremap [unite]a :Ag 
" }}}
" Spell check {{{
    nnoremap <F9> :call ToggleSpell()<CR>
    inoremap <F9> <Esc>:call ToggleSpell()<CR>a
" }}}
" nerdtree {{{
    noremap ,d :execute 'NERDTreeToggle ' . getcwd()<CR><C-W>b
    noremap <silent>,f :execute 'NERDTreeFind'<CR>
    let NERDTreeShowHidden=1  " display hidden files by default
    let NERDTreeQuitOnOpen = 1 " close NERDTree window when opening a file
" }}}
" bufkill {{{
    nnoremap ,w :bd<CR>
" }}}
" undotree {{{
    nnoremap <F10> :UndotreeToggle<CR>
" }}}
" Rake {{{
    function! RakeCommand(command) " {{{
      cexpr system("rake " . a:command)
      cw " show quickfix window already
    endfunction " }}}
    command! -nargs=+ -complete=file Rake call RakeCommand(<q-args>)
    noremap <leader>r :Rake<space>
" }}}

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made. (Only define it when not defined already.)
if !exists(":DiffOrig") " {{{
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
      \ | wincmd p | diffthis
endif " }}}
augroup FTCheck " {{{
  autocmd!
  autocmd BufRead,BufNewFile *.mkd,*.md,*.markdown  set ai tw=100 fo=tcroqn2 comments=n:&gt; ft=markdown
  autocmd BufRead *.proto set ft=proto
  autocmd BufRead,BufNewFile *.rb set iskeyword+=?,!
  autocmd BufRead,BufNewFile *.rss setfiletype xml
augroup END " }}}
augroup FTOptions " {{{
  autocmd!
  autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
  autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType c,cpp,java setlocal ts=4 sts=4 sw=4 expandtab
  autocmd FileType c,cpp setlocal iskeyword-=?,!
  autocmd FileType hs setlocal iskeyword-=.
  autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType qf wincmd J | setlocal wrap linebreak
augroup END " }}}
" helper functions {{{
    function! GetVisualSelection() " {{{
      try
        let a_save = @a
        normal! gv"ay
        echo @a
        return @a
      finally
        let @a = a_save
      endtry
    endfunction " }}}

    function! ToggleSpell() " {{{
      if !exists("b:spell")
        setlocal spell spelllang=en_us
        let b:spell = 1
      else
        setlocal nospell
        unlet b:spell
      endif
    endfunction " }}}

    function! SwitchWindowKeepCurrentDir() " {{{
      let current = getcwd()
      wincmd W
      cd `=current`
    endfunction " }}}

    function! SetWorkingDirToCurrentDir() " {{{
      cd %:p:h
      :pwd
    endfunction " }}}

    " create html from text
    command! Txt2html :call Text2html()
    function! Text2html() " {{{
      runtime! syntax/2html.vim :convert txt to html
    endfunction " }}}

    " Remove trailing whitespaces and ^M chars on write
    command! ClearWhitespaces :call ClearWhitespaces()
    function! ClearWhitespaces() " {{{
      :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\s\\+$","","")'))
      if has("unix") " remove DOS style line endings
        :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\r\\+$","","")'))
      endif
    endfunction " }}}

    " replace german Umlauts
    command! UmlautCleanup :call ReplaceUmlauts()
    function! ReplaceUmlauts() " {{{
      let s:line = line(".")
      let s:column = col(".")
      let s:save_report = &report
      set report=99999
      let s:mapping = {"ä":"ae","ö":"oe","ü":"ue","Ä":"Ae","Ö":"Oe","Ü":"Ue","ß":"ss"}
      for i in items(s:mapping)
        execute "%s/".i[0]."/".i[1]."/eIg"
      endfor
      let &report=s:save_report
      unlet s:save_report
      call cursor(s:line,s:column)
      unlet s:line
      unlet s:column
    endfunction " }}}
" }}}
" Highlight Word {{{
    " thanks Steve Losh
    function! HiInterestingWord(n) " {{{
      " Save our location.
      normal! mz
      " Yank the current word into the z register.
      normal! "zyiw
      " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
      let mid = 86750 + a:n
      " Clear existing matches, but don't worry if they don't exist.
      silent! call matchdelete(mid)
      " Construct a literal pattern that has to match at boundaries.
      let pat = '\V' . escape(@z, '\')
      " Actually match the words.
      call matchadd("InterestingWord" . a:n, pat, 1, mid)
      " Move back to our original location.
      normal! `z
    endfunction " }}}

    " Mappings {{{
    nnoremap <leader>h :call matchadd("InterestingWord1", "", 1, 4242)<C-F>F"<C-C>i
    nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
    nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
    nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
    nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
    nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
    nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>
    " }}}
    " Default Highlights {{{
    hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
    hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
    hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
    hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
    hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
    hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195
    " }}}
" }}}
