if has('gui_running')
  set guitablabel=%t " only display the filename not the path
  set guioptions-=T "remove toolbar
  set autochdir
endif
let g:SuperTabMappingForward = '<c-space>'
let g:SuperTabMappingBackward = '<s-c-space>'
let g:SuperTabLongestHighlight = 1
let g:SuperTabDefaultCompletionType = 'context'
let g:GetLatestVimScripts_allowautoinstall=1
syntax on
" enable filetype detection and plugin loading
filetype plugin on
colorscheme delek
set completeopt=longest,menuone,preview
set wildmode=longest:full " bash like filename completion
set wildmenu " show possible completions for filenames
set nocompatible
set backspace=indent,eol,start
set hlsearch
set incsearch
set hidden
set noswapfile " disable swapfiles
set ignorecase
set number
set smartcase
set scrolloff=1
set dictionary+=/usr/share/dict/words
set history=1000	          "keep 1000 lines of command line history
set ruler		                "show the cursor position all the time
set showcmd
set tabstop=2
set shiftwidth=2
set expandtab
set smarttab
set smartindent
set vb                      "visual beep
set autoread                "reload file if permissions change due to BufWritePost below
set autowrite               "write file to disk on :make, :!, :first, :next

:noremap <A-j> gT 
:map <A-k> gt
:noremap <A-Left> gT
:noremap <A-Right> gt
imap <C-Tab> <Esc> :bn<CR>
map <C-Tab> :bn<CR>
imap <C-S-Tab> <Esc> :bp<CR>
map <C-S-Tab> :bp<CR>
imap <C-S-Tab> <Esc> :bp<CR>

noremap ;; :%s:::g<Left><Left><Left>
noremap ;' :%s:::cg<Left><Left><Left><Left>

" au CursorMoved * exec 'match MyGroup /\<'.expand('<cword>').'\>/'
highlight MyGroup ctermbg=green guibg=green
" Make ',e' (in normal mode) give a prompt for opening files
" in the same dir as the current buffer's file.
if has("unix")
  map ,e :e <C-R>=expand("%:p:h") . "/" <CR>
else
  map ,e :e <C-R>=expand("%:p:h") . "\\" <CR>
endif

" plugin specific config
let macvim_hig_shift_movement = 1
let MRU_Max_Entries = 60 
let MRU_Window_Height = 25 
" haskell syntax config
let hs_highlight_delimiters = 1 " Highlight delimiter characters
let hs_highlight_boolean = 1 " Treat True and False as keywords.
let hs_highlight_types = 1 " Treat names of primitive types as keywords.
let hs_highlight_more_types = 1 " Treat names of other common types as keywords.
" hs_highlight_debug - Highlight names of debugging functions.
let g:utl_opt_verbose=1	" Switched on

" leo search of current word
nmap ,l :exe ":Utl ol http://dict.leo.org/?search=" . expand("<cword>")<CR>

" FindFile plugin shortcuts
nmap <C-S> :FindFile<CR>

"Vertical split then hop to new buffer
:noremap ,v :vsp<CR>^W^W<CR>
:noremap ,h :split<CR>^W^W<CR>
"Make current window the only one
:noremap ,O :only<CR>:tabo<CR>
:noremap ,o :only<CR>
:noremap ,m :execute 'make'<CR>
"Buffer next,previous (ctrl-{n,p})
:noremap ^N :bn<CR>
:noremap ^P :bp<CR>
"Buffer delete (ctrl-c)
:noremap ^C :bd<CR>

"mapping of F-*
imap <S-F1> <esc>:BufExplorer<CR>
map <S-F1> :BufExplorer<CR>
map <F1> :FufBuffer<CR>
imap <F1> <esc>:FufBuffer<CR>
map <F2> :FufDir<CR>
map <S-F2> :FufFile<CR>
imap <F3> <Esc><c-]><CR>
map <F3> <c-]><CR>
nmap <F4> :call ToggleSpell()<CR>
imap <F4> <Esc>:call ToggleSpell()<CR>a
map <F5> :call OpenInGhci()<CR><CR>
" Prepare a :substitute command using the current word or the selected text:
vnoremap <F6> y:%s/\<<C-r>"\>//gc<Left><Left><Left>
nmap <F6> y:%s/\<<C-r>=expand("<cword>")<CR>\>//gc<Left><Left><Left>
map <F7> :call OpenInTerminal()<CR><CR>
nnoremap <F8> :grep <C-R><C-W> *<CR> " search for the keyword under the cursor in the current directory using the 'grep' command
map <F9> :set list!<CR>   " toggle display of invisible characters
map <S-F9> :set wrap!<CR> " toggle wrap lines
" highlight current word wit F-12 and on mouse click
nnoremap <LeftRelease> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
inoremap <LeftRelease> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
noremap <F12> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
inoremap <F12> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
nnoremap <silent> <F11> :YRShow<CR>

vmap // y/<C-R>"<CR> " search for visually highlighted text
" use ghc functionality for haskell files
au BufEnter *.hs compiler ghc
:let g:ghc="/usr/bin/ghc"
function! GhciMake()
   cd %:h
   set makeprg=ghci\ %
   make
endfunction

" Spell check
function! ToggleSpell()
    if !exists("b:spell")
        setlocal spell spelllang=en_us
        let b:spell = 1
    else
        setlocal nospell
        unlet b:spell
    endif
endfunction

function! RakeCommand(command)
  cexpr system("rake " . a:command)
  cw " show quickfix window already
endfunction
command! -nargs=+ -complete=file Rake call RakeCommand(<q-args>)

map <leader>a :Ack<space>
nmap <unique> <Leader>x <Plug>ToggleAutoCloseMappings
map <leader>r :Rake<space>
map <leader>d :execute 'NERDTreeToggle ' . getcwd()<CR><C-W><C-W><CR>
map <leader>f :execute 'NERDTreeFind'<CR> 

" create html from text
function! Text2html()
  runtime! syntax/2html.vim :convert txt to html
endfunction 
command! Txt2html :call Text2html()

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
		  \ | wincmd p | diffthis
endif

augroup mkd
  autocmd BufRead *.mkd,*.md  set ai formatoptions=tcroqn2 comments=n:&gt;
augroup END

if has("mac")
  " moving lines, only for mac because of stupid option key behavior
  nnoremap ∆ mz:m+<CR>`z==
  nnoremap ˚ mz:m-2<CR>`z==
  inoremap ∆ <Esc>:m+<CR>==gi
  inoremap ˚ <Esc>:m-2<CR>==gi
  vnoremap ∆ :m'>+<CR>gv=`<my`>mzgv`yo`z
  vnoremap ˚ :m'<-2<CR>gv=`>my`<mzgv`yo`z
  set fileformats=mac,unix,dos
else
  " moving lines
  nnoremap <M-j> mz:m+<CR>`z==
  nnoremap <M-k> mz:m-2<CR>`z==
  inoremap <M-j> <Esc>:m+<CR>==gi
  inoremap <M-k> <Esc>:m-2<CR>==gi
  vnoremap <M-j> :m'>+<CR>gv=`<my`>mzgv`yo`z
  vnoremap <M-k> :m'<-2<CR>gv=`>my`<mzgv`yo`z
endif
if has("mac")
  let $PATH=$PATH . ":/opt/local/bin"
  if has('gui_running')
    set guifont=Courier:h11
    set lines=60
    set columns=200
  endif
  let g:utl_cfg_hdl_mt_application_pdf = ':silent !open %p &'
  let g:utl_cfg_hdl_scm_http = 'silent !open %u'
  map <F7> :!term %<CR>
  function! OpenInGhci()
    !term ghci %
  endfunction
  let g:haddock_browser = "open"
  let g:haddock_browser_callformat = "%s -a Firefox %s"
  let g:ack_grep_commend_string="ack "
elseif has("unix")
if has('gui_running')
    set guifont=Courier\ 10\ pitch\ 8
    set lines=60
    set columns=200
  endif
  let g:utl_cfg_hdl_mt_application_pdf = ':silent !gnome-open %p &'
  function! OpenInTerminal()
    !gnome-terminal --profile=light --geometry=160x50 %
  endfunction
  function! OpenInGhci()
    !gnome-terminal --profile=small --geometry=160x50 -e "ghci -i.. %"
  endfunction
  let g:haddock_browser = "/usr/bin/firefox"
  let g:haddock_browser_callformat = "%s --new-tab file://%s &"
  let g:ack_grep_commend_string="ack-grep "
elseif has("win32") || has("win64")
  if has('gui_running')
    set guifont=courier_New:h8
    set lines=75
    set columns=200
  endif
  " let g:utl_cfg_hdl_mt_application_pdf = ':silent !gnome-open %p &'

  function! OpenInTerminal()
    !start cmd %<CR>
  endfunction
  function! OpenInGhci()
    !start ghci -i.. %
  endfunction
  let g:haddock_browser = "c:\Programs\firefox3\firefox.exe"
  let g:haddock_browser_callformat = "%s -a Firefox %s"
  let g:ack_grep_commend_string="ack "
endif

function! AckGrep(command)
  cexpr system(g:ack_grep_commend_string . a:command)
  cw " show quickfix window already
endfunction
command! -nargs=+ -complete=file Ack call AckGrep(<q-args>)
