set nocompatible                " make Vim behave in a more useful way, less vi compatible
filetype off                    " required!
set rtp+=~/.vim/bundle/vundle/  " let Vundle manage Vundle
call vundle#rc()

Bundle 'gmarik/vundle'
Bundle 'L9'
Bundle 'tpope/vim-fugitive'
Bundle 'tpope/vim-surround'
Bundle 'tpope/vim-repeat'
Bundle 'godlygeek/tabular'
Bundle 'tomtom/tcomment_vim'
Bundle 'scrooloose/nerdtree'
Bundle 'digitaltoad/vim-jade'
Bundle 'thinca/vim-quickrun'
Bundle 'sjl/gundo.vim'
Bundle 'msanders/snipmate.vim'
Bundle 'kien/ctrlp.vim'
Bundle 'Shougo/neocomplcache'
Bundle 'osyo-manga/neocomplcache-clang_complete'
" Bundle 'Rip-Rip/clang_complete'
Bundle 'Raimondi/delimitMate'
Bundle 'derekwyatt/vim-fswitch'
Bundle 'godlygeek/csapprox'
Bundle 'sessionman.vim'
Bundle 'altercation/vim-colors-solarized'
Bundle 'veloce/vim-aldmeris'
Bundle 'bufkill.vim'
Bundle 'BufOnly.vim'
Bundle 'taglist.vim'
Bundle 'matchit.zip'
Bundle 'mru.vim'
Bundle 'eagletmt/ghcmod-vim'
Bundle 'dag/vim2hs'
Bundle 'Shougo/vimproc'
Bundle 'ujihisa/neco-ghc'
Bundle 'marcmo/haskellmode-vim'
Bundle 'AndrewRadev/switch.vim'
Bundle 'Lokaltog/vim-easymotion'
Bundle 'tpope/vim-foreplay'
Bundle 'guns/vim-clojure-static'

filetype plugin indent on           " required!

" UI Stuff {
    syntax on
    set background=dark
    if filereadable(expand("~/.vim/bundle/vim-aldmeris/colors/aldmeris.vim"))
      let g:aldmeris_termcolors = "tango"
      colorscheme aldmeris
    elseif
      filereadable(expand("~/.vim/bundle/vim-colors-solarized/colors/solarized.vim"))
      colorscheme solarized
    endif
    if has('gui_running')
      set guitablabel=%t            " only display the filename not the path
      set guioptions-=m             " remove [m]enubar
      set guioptions-=T             " remove [T]oolbar
      set cursorline                " highlight the screen line of the cursor
    else
      set t_Co=256                  " we want full colors in terminal
    endif
    if has('statusline')
      set laststatus=2                         " always show statusline
      set statusline=%<%f\                     " Filename
      set statusline+=%w%h%m%r                 " Options
      set statusline+=%{fugitive#statusline()} " Git Hotness
      set statusline+=\ [%{&ff}/%Y]            " filetype
      set statusline+=\ [%{getcwd()}]          " current dir
      set statusline+=%=%-14.(%l,%c%V%)\ %p%%  " Right aligned file nav info
    endif
    if has('cmdline_info')
      set ruler                     " show the cursor position all the time
      set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " a ruler on steroids
      set showcmd                   " show (partial) command in the last line of the screen
    endif
" }
" basic settings {
    set laststatus=2
    set wildignore+=*.o,*.obj,*.o.d,.git,*.a,*.d,tags
    set nofoldenable                " disable folding
    set showmode                    " always show what mode we're currently editing in
    set nowrap                      " don't wrap lines
    set tabstop=2                   " a tab is 2 spaces by default
    set softtabstop=2               " when hitting <BS>, pretend like a tab is removed, even if spaces
    set expandtab                   " expand tabs default
    set shiftwidth=2                " number of spaces to use for autoindenting
    set shiftround                  " use multiple of shiftwidth when indenting with '<' and '>'
    set backspace=indent,eol,start  " allow backspacing over everything in insert mode
    set autoindent                  " always set autoindenting on
    set copyindent                  " copy the previous indentation on autoindenting
    set ignorecase                  " ignore case when searching
    set smartcase                   " ignore case if all lowercase, otherwise case-sensitive
    set smarttab                    " insert tabs on the start of a line according to shiftwidth
    set scrolloff=3                 " keep off the edges of the screen when scrolling
    set virtualedit=block           " allow virtual editing in Visual block mode.
    set winminheight=0              " windows can be 0 line high
    set hlsearch                    " highlight search terms
    set incsearch                   " show search matches as you type
    set completeopt=longest,menuone,preview
    set wildmode=longest:full       " bash like filename completion
    set wildmenu                    " show possible completions for filenames
    set hidden
    set noswapfile                  " disable swapfiles
    set history=1000                " keep 1000 lines of command line history
    set smartindent                 " do smart autoindenting when starting a new line
    set vb                          " visual beep
    set autoread                    " reload file if permissions change due to BufWritePost below
    set autowrite                   " write file to disk on :make, :!, :first, :next
    set gcr=n:blinkon0              " turn of blinking cursor in normal mode
    set synmaxcol=800               " Don't try to highlight lines longer than 800 characters.
" }
" general utilities {
    " quick way to escape from insert mode
    inoremap jj <ESC>
    inoremap kj <ESC>
    " use :w!! to write to a file using sudo
    cnoremap w!! %!sudo tee > /dev/null %
    nnoremap<leader>l :set list!<CR>
    " Yank from the cursor to the end of the line, to be consistent with C and D.
    nnoremap Y y$
    " leave the cursor at the point where it was before editing started
    nnoremap . .`[
    noremap <F7> :call OpenInTerminal()<CR><CR>
    " Go to newer/older text state
    nnoremap <S-F11> g-
    nnoremap <S-F12> g+
    " Wrapped lines goes down/up to next row, rather than next line in file.
    nnoremap j gj
    nnoremap k gk
    nnoremap ,rc :vsplit ~/.vim/_vimrc_universal <CR>
    nnoremap ,bc :e ~/.bashrc <CR>
    " move lines up and down
    nnoremap <M-Down> mz:m+<CR>`z==
    nnoremap <M-Up> mz:m-2<CR>`z==
    inoremap <M-Down> <Esc>:m+<CR>==gi
    inoremap <M-Up> <Esc>:m-2<CR>==gi
    vnoremap <M-Down> :m'>+<CR>gv=`<my`>mzgv`yo`z
    vnoremap <M-Up> :m'<-2<CR>gv=`>my`<mzgv`yo`z
    " trailing whitespaces {
        " highlight end of line whitespace as Error
        hi link ExtraWhitespace Error
        augroup whitespaces
          autocmd!
          autocmd BufNewFile,BufRead,InsertLeave * match ExtraWhitespace /\s\+$/
          " except the line I am typing on
          autocmd InsertEnter * match ExtraWhitespace /\s\+\%#\@<!$/
          nnoremap <Leader>c :call ClearWhitespaces()<CR>
        augroup END
    " }
    " directories and files {
        noremap ,cd :call SetWorkingDirToCurrentDir()<CR>
        " climb up one directory level
        noremap <leader>u :cd ..<CR>:pwd<CR>
        " Some helpers to edit mode (http://vimcasts.org/e/14)
        cnoremap %% <C-R>=expand('%:h').'/'<cr>
        noremap <leader>ew :e %%
        noremap <leader>es :sp %%
        noremap <leader>ev :vsp %%
        noremap <leader>et :tabe %%
        " prompt for opening files in the same dir as the current buffer's file.
        if has("unix")
          let g:os_specific_delimiter="/"
        else
          let g:os_specific_delimiter="\\"
        endif
        noremap ,e :e <C-R>=expand("%:p:h") . g:os_specific_delimiter <CR>
    " }
    " search and substitution {
        " use normal regexes in search
        nnoremap / /\v
        vnoremap / /\v
        " search for the keyword under the cursor in the current directory using the 'grep' command
        nnoremap <F8> :grep <C-R><C-W> *<CR>
        " search for visually highlighted text
        vnoremap // y/<C-R>"<CR>
        " Prepare a :substitute command using the current word or the selected text:
        vnoremap <F6> y:%s/\<<C-r>"\>//gc<Left><Left><Left>
        nnoremap <F6> y:%s/\<<C-r>=expand("<cword>")<CR>\>//gc<Left><Left><Left>
    " }
    " movement {
        " jump back and forth between the last 2 files
        inoremap <C-Tab> <Esc>:e#<CR>
        noremap <C-Tab> :e#<CR>
        inoremap <C-S-Tab> <Esc> :bp<CR>
        noremap <C-S-Tab> :bp<CR>
        " jump to next/previous quickfix
        nnoremap <F4> :cn<CR>
        inoremap <F4> <Esc>:cn<CR>a
        nnoremap <S-F4> :cp<CR>
        inoremap <S-F4> <Esc>:cp<CR>a
    " }
    " hippie occurrence {
        " highlight current word with <F12> and on mouse click
        nnoremap <LeftRelease> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
        inoremap <LeftRelease> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
        noremap <F12> :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
        inoremap <F12> <Esc>:let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>li
    " }
    " window handling {
        set splitbelow splitright " Create split windows in more intuitive places
        " [v]ertical or [h]orizontal split then hop to new buffer
        nnoremap ,v :vsp<CR>^W^W<CR>
        nnoremap ,h :split<CR>^W^W<CR>
        nnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
        vnoremap <silent> ;; :call SwitchWindowKeepCurrentDir()<CR>
        "Make current window the only one
        nnoremap ,o :only<CR>
    " }
" }
" programming {
      nnoremap <silent>,m :execute 'make'<CR>
      autocmd BufNewFile,BufRead *.cpp,*.h,*.html set matchpairs+=<:>
    " formatting {
        augroup astyle
          autocmd!
          autocmd BufNewFile,BufRead *.cpp,*.c,*.h set formatprg=astyle\ -A1sYHjk1
        augroup END
        " format complete file and return to starting position using mark 'b'
        nnoremap <Leader>f mbgggqG`b
    " }
    " taglist {
        nnoremap <silent> <S-F9> :TlistToggle<CR>
    " }
    " ctags {
        set tags=tags;$HOME
        " Open the definition in a vertical split
        noremap <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
        " lookup symbol in tags file
        inoremap <F3> <Esc><c-]><CR>
        noremap <F3> <c-]><CR>
        " jump to next tag
        nnoremap <S-F3> :tn<CR>
        inoremap <S-F3> <Esc>:tn<CR>a
        noremap <S-F8> :!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q --exclude=*.html .<CR>
    " }
    " " clang {
    "     let g:clang_auto_select=1
    "     let g:clang_complete_auto=0
    "     let g:clang_complete_copen=1
    "     let g:clang_snippets=1
    "     let g:clang_snippets_engine = "snipmate"
    "     let g:clang_exec="clang"
    "     let g:clang_user_options=""
    "     let g:clang_auto_user_options="path, .clang_complete"
    "     let g:clang_use_library=1
    "     let g:clang_library_path="/usr/local/lib"
    "     let g:clang_sort_algo="priority"
    "     let g:clang_complete_macros=1
    "     let g:clang_complete_patterns=0
    "     nnoremap <Leader>q :call g:ClangUpdateQuickFix()<CR>
    " " }
    " fswitch {
        let g:fsnonewfiles=1
        let g:fswitchnonewfiles=1
        " Create the destination path by substituting any 'include' string from the pathname with 'src'
        let b:fswitchlocs = 'reg:/include/src/'
        augroup mycppfiles
          autocmd!
          autocmd BufEnter *.h let b:fswitchdst  = 'cpp,cc,C'
          autocmd BufEnter *.h let b:fswitchlocs = 'reg:/include/src/,reg:/include.*/src/,..'
          autocmd BufEnter *.c  let b:fswitchdst  = 'h'
          autocmd BufEnter *.c  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include'
          autocmd BufEnter *.cpp,*.cc  let b:fswitchdst  = 'h'
          autocmd BufEnter *.cpp,*.cc  let b:fswitchlocs = 'reg:/src/include/,reg:|src|include/**|,../include,include'
        augroup END
        nnoremap <silent>,, :FSHere<cr>
        vnoremap <silent>,, :FSHere<cr>
    " }
    " switch.vim {
        nnoremap - :Switch<cr>
    " }
    " quickrun {
        let g:quickrun_config = {}
        let g:quickrun_config.haskell = {'eval' : 1 }
        let g:quickrun_config.c = {'type' :
        \     executable('clang')          ? 'c/clang' :
        \     executable('gcc')            ? 'c/gcc' : ''}
        nnoremap <silent> ,rr :QuickRun -mode n<CR>
        vnoremap <silent> ,rr :QuickRun -mode v<CR>
    " }
    " vim2hs {
        let g:haskell_conceal = 0
    " }
    " ghcmod-vim {
        let g:ghcmod_hlint_options = ['--ignore=Use camelCase', '--ignore=Top-level binding $']
        let g:ghcmod_ghc_options = ['-fno-warn-missing-signatures','-fno-warn-type-defaults']
        augroup ghcmod
          autocmd!
          autocmd BufWritePost *.hs GhcModCheckAndLintAsync
          autocmd bufenter *.hs,*.lhs nnoremap <buffer> ,gh :GhcModType<CR>
          autocmd bufenter *.hs,*.lhs nnoremap <buffer> ,gc :GhcModTypeClear<CR>
        augroup END
    " }
    " haskellmode-vim {
        let hs_highlight_delimiters = 1 " Highlight delimiter characters
        let hs_highlight_boolean = 1 " Treat True and False as keywords.
        let hs_highlight_types = 1 " Treat names of primitive types as keywords.
        let hs_highlight_more_types = 1 " Treat names of other common types as keywords.
        augroup haskellmode
          autocmd!
          autocmd BufWritePost *.hs GHCReload
          autocmd BufEnter *.hs compiler ghc
        augroup END
    " }
    " haskell {
        " use ghc functionality for haskell files
        function! EvaluateInGhc() range
          let current = GetVisualSelection()
          let result = system('ghc -e '.shellescape(current))
          call setline(".", result)
        endfunction
        vnoremap <leader>e :call EvaluateInGhc()<CR>$x<esc>0
        augroup hs
          autocmd!
          autocmd bufenter *.hs,*.lhs noremap <F5> :call OpenInGhci()<CR><CR>
          autocmd bufenter *.hs,*.lhs setlocal ts=2 sts=2 sw=2 expandtab
        augroup END
    " }
    " javascript {
        augroup js
            setlocal ts=2 sts=2 sw=2 expandtab
            autocmd bufenter *.js,*.html set makeprg=jslint\ %
            setlocal efm=%f:%l:%c:%m
        augroup END
    " }
    " lua {
        augroup lua
          autocmd!
          setlocal mp=lua\ % ts=2 sts=2 sw=2 noexpandtab
          autocmd bufenter *.lua noremap <F5> :call OpenWithLua()<CR><CR>
        augroup END
    " }
    " c++ {
        augroup cpp
          autocmd!
          autocmd bufenter *.cpp,*.h setlocal mp=clang++\ -std=c++11\ -I/Volumes/macbox_cs/dev/git/boost.git/\ -o\ %<\ %
          autocmd bufenter *.cpp nnoremap <F5> :update<CR>:call MakeCpp()<CR>
          autocmd QuickFixCmdPost [^l]* nested cwindow
          autocmd QuickFixCmdPost    l* nested lwindow
        augroup END
        " Save and make current file.o
        function! MakeCpp()
          let curr_dir = expand('%:h')
          if curr_dir == ''
            let curr_dir = '.'
          endif
          echo curr_dir
          execute 'lcd ' . curr_dir
          execute 'make'
          execute 'lcd -'
        endfunction
    " }
" }
" neocomplcache {
    let g:acp_enableAtStartup = 0
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_force_overwrite_completefunc=1
    " let g:neocomplcache_disable_auto_complete = 1
    let g:neocomplcache_enable_camel_case_completion = 1
    let g:neocomplcache_enable_smart_case = 1
    let g:neocomplcache_enable_underbar_completion = 1
    let g:neocomplcache_min_syntax_length = 3
    let g:neocomplcache_enable_auto_delimiter = 1
    let g:neocomplcache_enable_auto_select = 1
    " <ctrl-space>: completion.
    inoremap <expr><c-space> neocomplcache#start_manual_complete()
    " SuperTab like snippets behavior.
    inoremap <expr><TAB> neocomplcache#sources#snippets_complete#expandable() ? "\<Plug>(neocomplcache_snippets_expand)" : pumvisible() ? "\<C-n>" : "\<TAB>"

    " Plugin key-mappings.
    inoremap <C-k>     <Plug>(neocomplcache_snippets_expand)
    snoremap <C-k>     <Plug>(neocomplcache_snippets_expand)
    inoremap <expr><C-g>     neocomplcache#undo_completion()
    inoremap <expr><C-l>     neocomplcache#complete_common_string()

    " <CR>: close popup
    " <s-CR>: close popup and save indent.
    inoremap <expr><CR>  pumvisible() ? neocomplcache#close_popup() : "\<CR>"
    inoremap <expr><s-CR> pumvisible() ? neocomplcache#close_popup() "\<CR>" : "\<CR>"
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

    " <C-h>, <BS>: close popup and delete backword char.
    inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplcache#close_popup()
    inoremap <expr><C-e>  neocomplcache#cancel_popup()

    augroup neocompl
      autocmd!
    " Enable omni completion.
      autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
      autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
      autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
      autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
      autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
    augroup END

    " Enable heavy omni completion.
    if !exists('g:neocomplcache_omni_patterns')
      let g:neocomplcache_omni_patterns = {}
    endif
    let g:neocomplcache_omni_patterns.c = '\%(\.\|->\)\h\w*'
    let g:neocomplcache_omni_patterns.cpp = '\h\w*\%(\.\|->\)\h\w*\|\h\w*::'

    " For snippet_complete marker.
    if has('conceal')
      set conceallevel=2 concealcursor=i
    endif
" }
" Session List {
    set sessionoptions=blank,buffers,curdir,folds,options,tabpages,winsize
    nnoremap ,sl :SessionList<CR>
    nnoremap ,ss :SessionSave<CR>
" }
" fugitiv {
    function! CloseFugitiveDiffAfterUsage()
      diffoff!
      close
      wincmd k
    endfunction
    autocmd BufReadPost fugitive://* set bufhidden=delete
    noremap ,k :call CloseFugitiveDiffAfterUsage()<CR>
" }
" mru {
    let MRU_Max_Entries = 200
    let MRU_Window_Height = 25
    " nnoremap ,u :MRU<CR>
" }
" ctrlp {
    let g:ctrlp_max_height = 25
    let g:ctrlp_custom_ignore = '^\.git$\|\.hg$\|\.svn$\|\.metadata$|tags$'
    let g:ctrlp_by_filename = 1
    let g:ctrlp_max_files = 30000
    let g:ctrlp_match_window_bottom = 0
    let g:ctrlp_match_window_reversed = 0
    let g:ctrlp_mruf_max = 200
    let g:ctrlp_mruf_default_order = 0
    let g:ctrlp_working_path_mode = 'a'
    nnoremap ,u :CtrlPMRU<CR>
    noremap <F1> :CtrlPBuffer<CR>
    inoremap <F1> <esc>:CtrlPBuffer<CR>
    noremap <S-F1> :CtrlPBufTagAll<CR>
    inoremap <S-F1> <esc>:CtrlPBufTagAll<CR>
    noremap <leader>t :CtrlP<CR>
" }
" Spell check {
    nnoremap <F9> :call ToggleSpell()<CR>
    inoremap <F9> <Esc>:call ToggleSpell()<CR>a
" }
" nerdtree {
    noremap ,d :execute 'NERDTreeToggle ' . getcwd()<CR><C-W>b
    noremap ,f :execute 'NERDTreeFind'<CR>
    let NERDTreeShowHidden=1  " display hidden files by default
" }
" bufkill {
    nnoremap ,w :BD<CR>
" }
" gundo {
    nnoremap <F10> :GundoToggle<CR>
" }
" Rake {
    function! RakeCommand(command)
      cexpr system("rake " . a:command)
      cw " show quickfix window already
    endfunction
    command! -nargs=+ -complete=file Rake call RakeCommand(<q-args>)
    noremap <leader>r :Rake<space>
" }
" ack {
    function! AckGrep(command)
      cexpr system("ack " . a:command)
      cw " show quickfix window already
    endfunction
    command! -nargs=+ -complete=file Ack call AckGrep(<q-args>)
    noremap <leader>a :Ack<space>-G ".*\.(c\|cpp\|h\|hs\|lua\|py\|rb)$"<space>
" }

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made. (Only define it when not defined already.)
if !exists(":DiffOrig")
  command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
      \ | wincmd p | diffthis
endif
augroup mkd
  autocmd!
  autocmd BufRead *.mkd,*.md,*.markdown  set ai formatoptions=tcroqn2 comments=n:&gt; filetype=markdown
augroup END
autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab
autocmd FileType yaml setlocal ts=2 sts=2 sw=2 expandtab
autocmd FileType css setlocal ts=2 sts=2 sw=2 expandtab
autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab
autocmd FileType c,cpp,java setlocal ts=4 sts=4 sw=4 expandtab
autocmd FileType c,cpp setlocal iskeyword-=?,!
augroup html
  autocmd!
  autocmd FileType html setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType html set makeprg=jslint\ %
  setlocal efm=%f:%l:%c:%m
augroup END
augroup newbuf
  autocmd!
  autocmd BufRead,BufNewFile *.rb set iskeyword+=?,!
  autocmd BufRead,BufNewFile *.rss setfiletype xml
augroup END
" move through camelcase words {
    "" Use one of the following to define the camel characters.
    " Stop on capital letters.
    let g:camelchar = "A-Z"
    " Also stop on numbers.
    let g:camelchar = "A-Z0-9"
    " Include '.' for class member, ',' for separator, ';' end-statement,
    " and <[< bracket starts and "'` quotes.
    let g:camelchar = "A-Z0-9.,;:{([`'\""
    nnoremap <silent><C-Left> :<C-u>call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%^','bW')<CR>
    nnoremap <silent><C-Right> :<C-u>call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%$','W')<CR>
    inoremap <silent><C-Left> <C-o>:call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%^','bW')<CR>
    inoremap <silent><C-Right> <C-o>:call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%$','W')<CR>
    vnoremap <silent><C-Left> :<C-U>call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%^','bW')<CR>v`>o
    vnoremap <silent><C-Right> <Esc>`>:<C-U>call search('\C\<\<Bar>\%(^\<Bar>[^'.g:camelchar.']\@<=\)['.g:camelchar.']\<Bar>['.g:camelchar.']\ze\%([^'.g:camelchar.']\&\>\@!\)\<Bar>\%$','W')<CR>v`<o
" }
" helper functions {
    function! GetVisualSelection()
      try
        let a_save = @a
        normal! gv"ay
        echo @a
        return @a
      finally
        let @a = a_save
      endtry
    endfunction

    function! ToggleSpell()
      if !exists("b:spell")
        setlocal spell spelllang=en_us
        let b:spell = 1
      else
        setlocal nospell
        unlet b:spell
      endif
    endfunction

    function! SwitchWindowKeepCurrentDir()
      let current = getcwd()
      wincmd W
      cd `=current`
    endfunction

    function! SetWorkingDirToCurrentDir()
      cd %:p:h
      :pwd
    endfunction

    " create html from text
    command! Txt2html :call Text2html()
    function! Text2html()
      runtime! syntax/2html.vim :convert txt to html
    endfunction

    " Remove trailing whitespaces and ^M chars on write
    command! ClearWhitespaces :call ClearWhitespaces()
    function! ClearWhitespaces()
      :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\s\\+$","","")'))
      if has("unix") " remove DOS style line endings
        :call setline(1,map(getline(1,"$"),'substitute(v:val,"\\r\\+$","","")'))
      endif
    endfunction
" }

